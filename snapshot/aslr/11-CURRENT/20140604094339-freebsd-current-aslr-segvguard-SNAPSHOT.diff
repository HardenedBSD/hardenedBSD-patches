diff --git a/bin/rmail/Makefile b/bin/rmail/Makefile
index ad788a4..b998c03 100644
--- a/bin/rmail/Makefile
+++ b/bin/rmail/Makefile
@@ -14,6 +14,8 @@ MAN=	rmail.8
 WARNS?=	2
 CFLAGS+=-I${SENDMAIL_DIR}/include -I.
 
+NO_PIE=yes
+
 LIBSMDIR=	${.OBJDIR}/../../lib/libsm
 LIBSM=		${LIBSMDIR}/libsm.a
 
diff --git a/gnu/usr.bin/binutils/addr2line/Makefile b/gnu/usr.bin/binutils/addr2line/Makefile
index 2380738..7fc7c70 100644
--- a/gnu/usr.bin/binutils/addr2line/Makefile
+++ b/gnu/usr.bin/binutils/addr2line/Makefile
@@ -14,4 +14,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/nm/Makefile b/gnu/usr.bin/binutils/nm/Makefile
index 4ef2b8f..838af7f 100644
--- a/gnu/usr.bin/binutils/nm/Makefile
+++ b/gnu/usr.bin/binutils/nm/Makefile
@@ -15,4 +15,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/objcopy/Makefile b/gnu/usr.bin/binutils/objcopy/Makefile
index 66d99f4..312f5ce 100644
--- a/gnu/usr.bin/binutils/objcopy/Makefile
+++ b/gnu/usr.bin/binutils/objcopy/Makefile
@@ -14,4 +14,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/objdump/Makefile b/gnu/usr.bin/binutils/objdump/Makefile
index 1a0d046..2c3425f 100644
--- a/gnu/usr.bin/binutils/objdump/Makefile
+++ b/gnu/usr.bin/binutils/objdump/Makefile
@@ -16,4 +16,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/readelf/Makefile b/gnu/usr.bin/binutils/readelf/Makefile
index d90c3bc..ef761b0 100644
--- a/gnu/usr.bin/binutils/readelf/Makefile
+++ b/gnu/usr.bin/binutils/readelf/Makefile
@@ -17,4 +17,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/size/Makefile b/gnu/usr.bin/binutils/size/Makefile
index c5c19c1..07d9fb5 100644
--- a/gnu/usr.bin/binutils/size/Makefile
+++ b/gnu/usr.bin/binutils/size/Makefile
@@ -14,4 +14,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/strings/Makefile b/gnu/usr.bin/binutils/strings/Makefile
index a432d51..8e83419 100644
--- a/gnu/usr.bin/binutils/strings/Makefile
+++ b/gnu/usr.bin/binutils/strings/Makefile
@@ -14,4 +14,6 @@ DPADD+=	${RELTOP}/libbfd/libbfd.a
 DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/binutils/strip/Makefile b/gnu/usr.bin/binutils/strip/Makefile
index d3cf8c4..9a325de 100644
--- a/gnu/usr.bin/binutils/strip/Makefile
+++ b/gnu/usr.bin/binutils/strip/Makefile
@@ -15,4 +15,6 @@ DPADD+=	${RELTOP}/libiberty/libiberty.a
 LDADD=	${DPADD}
 INSTALLFLAGS= -S
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/gdb/gdb/Makefile b/gnu/usr.bin/gdb/gdb/Makefile
index 15eb2eb..2ead3d6 100644
--- a/gnu/usr.bin/gdb/gdb/Makefile
+++ b/gnu/usr.bin/gdb/gdb/Makefile
@@ -14,5 +14,7 @@ LDFLAGS+= -Wl,-E
 DPADD=	${GDBLIBS} ${BULIBS} ${LIBM} ${LIBREADLINE} ${LIBTERMCAP} ${LIBGNUREGEX}
 LDADD=	${GDBLIBS} ${BULIBS} -lm -lreadline -ltermcap -lgnuregex
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 CFLAGS+=	-DDEBUGDIR=\"${DEBUGDIR}\"
diff --git a/gnu/usr.bin/gdb/gdbtui/Makefile b/gnu/usr.bin/gdb/gdbtui/Makefile
index 94dbb4b..5e4a0a9 100644
--- a/gnu/usr.bin/gdb/gdbtui/Makefile
+++ b/gnu/usr.bin/gdb/gdbtui/Makefile
@@ -15,4 +15,6 @@ LDFLAGS+= -Wl,-E
 DPADD=	${GDBLIBS} ${BULIBS} ${LIBM} ${LIBREADLINE} ${LIBTERMCAP} ${LIBGNUREGEX}
 LDADD=	${GDBLIBS} ${BULIBS} -lm -lreadline -ltermcap -lgnuregex
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/gdb/kgdb/Makefile b/gnu/usr.bin/gdb/kgdb/Makefile
index 30cbf3c..7dbe0f2 100644
--- a/gnu/usr.bin/gdb/kgdb/Makefile
+++ b/gnu/usr.bin/gdb/kgdb/Makefile
@@ -17,4 +17,6 @@ LDADD=	${GDBLIBS} ${BULIBS} -lkvm${GDB_SUFFIX} -lm -lreadline -ltermcap \
 CFLAGS+= -Wl,-export-dynamic
 .endif
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grodvi/Makefile b/gnu/usr.bin/groff/src/devices/grodvi/Makefile
index 3745440..542a8ce 100644
--- a/gnu/usr.bin/groff/src/devices/grodvi/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grodvi/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grohtml/Makefile b/gnu/usr.bin/groff/src/devices/grohtml/Makefile
index 321f1c8..d50c49e 100644
--- a/gnu/usr.bin/groff/src/devices/grohtml/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grohtml/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 MAN=
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grolbp/Makefile b/gnu/usr.bin/groff/src/devices/grolbp/Makefile
index 85a41c1..af86af2 100644
--- a/gnu/usr.bin/groff/src/devices/grolbp/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grolbp/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grolj4/Makefile b/gnu/usr.bin/groff/src/devices/grolj4/Makefile
index bb3f9e4..d1be7fa 100644
--- a/gnu/usr.bin/groff/src/devices/grolj4/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grolj4/Makefile
@@ -7,4 +7,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grops/Makefile b/gnu/usr.bin/groff/src/devices/grops/Makefile
index 4511f69..09d9311 100644
--- a/gnu/usr.bin/groff/src/devices/grops/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grops/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/devices/grotty/Makefile b/gnu/usr.bin/groff/src/devices/grotty/Makefile
index d15ee8b..ea3ef05 100644
--- a/gnu/usr.bin/groff/src/devices/grotty/Makefile
+++ b/gnu/usr.bin/groff/src/devices/grotty/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBDRIVER} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBDRIVER} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/eqn/Makefile b/gnu/usr.bin/groff/src/preproc/eqn/Makefile
index 80871fe..19d2f9d 100644
--- a/gnu/usr.bin/groff/src/preproc/eqn/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/eqn/Makefile
@@ -11,6 +11,8 @@ SCRIPTS=	neqn
 MAN=		eqn.1 neqn.1
 CLEANFILES=	eqn.cpp eqn_tab.h ${SCRIPTS} ${MAN} y.tab.c y.tab.h
 
+NO_PIE=yes
+
 eqn_tab.h: eqn.cpp
 
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/grn/Makefile b/gnu/usr.bin/groff/src/preproc/grn/Makefile
index 58309d2..04c1b45 100644
--- a/gnu/usr.bin/groff/src/preproc/grn/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/grn/Makefile
@@ -6,4 +6,6 @@ DPADD=	 	${LIBGROFF} ${LIBM}
 LDADD=	 	${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/html/Makefile b/gnu/usr.bin/groff/src/preproc/html/Makefile
index d46626b..ec4a1df 100644
--- a/gnu/usr.bin/groff/src/preproc/html/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/html/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF}
 LDADD=		${LIBGROFF}
 MAN=
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/pic/Makefile b/gnu/usr.bin/groff/src/preproc/pic/Makefile
index 3b5939c..004bba4 100644
--- a/gnu/usr.bin/groff/src/preproc/pic/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/pic/Makefile
@@ -8,6 +8,8 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	${MAN} pic.cpp pic_tab.h y.tab.c y.tab.h
 
+NO_PIE=yes
+
 pic_tab.h: pic.cpp
 
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/refer/Makefile b/gnu/usr.bin/groff/src/preproc/refer/Makefile
index 8a18f6f..6b58e6a 100644
--- a/gnu/usr.bin/groff/src/preproc/refer/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/refer/Makefile
@@ -7,4 +7,6 @@ DPADD=		${LIBBIB} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBBIB} ${LIBGROFF} -lm
 CLEANFILES=	label.cpp label_tab.h ${MAN} y.tab.c y.tab.h
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/soelim/Makefile b/gnu/usr.bin/groff/src/preproc/soelim/Makefile
index 2c68b80..9727d80 100644
--- a/gnu/usr.bin/groff/src/preproc/soelim/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/soelim/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF}
 LDADD=		${LIBGROFF}
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/preproc/tbl/Makefile b/gnu/usr.bin/groff/src/preproc/tbl/Makefile
index 29e7ac2..c914619 100644
--- a/gnu/usr.bin/groff/src/preproc/tbl/Makefile
+++ b/gnu/usr.bin/groff/src/preproc/tbl/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/roff/groff/Makefile b/gnu/usr.bin/groff/src/roff/groff/Makefile
index 2ae541b..73bb368 100644
--- a/gnu/usr.bin/groff/src/roff/groff/Makefile
+++ b/gnu/usr.bin/groff/src/roff/groff/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/roff/troff/Makefile b/gnu/usr.bin/groff/src/roff/troff/Makefile
index 802af2b..ec6f57f 100644
--- a/gnu/usr.bin/groff/src/roff/troff/Makefile
+++ b/gnu/usr.bin/groff/src/roff/troff/Makefile
@@ -7,6 +7,8 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	majorminor.cpp ${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 majorminor.cpp: ${GROFF_DIST}/VERSION ${GROFF_DIST}/REVISION
diff --git a/gnu/usr.bin/groff/src/utils/addftinfo/Makefile b/gnu/usr.bin/groff/src/utils/addftinfo/Makefile
index 26fbb57..e412d4c 100644
--- a/gnu/usr.bin/groff/src/utils/addftinfo/Makefile
+++ b/gnu/usr.bin/groff/src/utils/addftinfo/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF}
 LDADD=		${LIBGROFF}
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/utils/hpftodit/Makefile b/gnu/usr.bin/groff/src/utils/hpftodit/Makefile
index 1376702..fba0928 100644
--- a/gnu/usr.bin/groff/src/utils/hpftodit/Makefile
+++ b/gnu/usr.bin/groff/src/utils/hpftodit/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/utils/indxbib/Makefile b/gnu/usr.bin/groff/src/utils/indxbib/Makefile
index b2c59a2..63cacd5 100644
--- a/gnu/usr.bin/groff/src/utils/indxbib/Makefile
+++ b/gnu/usr.bin/groff/src/utils/indxbib/Makefile
@@ -6,6 +6,8 @@ DPADD=		${LIBBIB} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBBIB} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 beforeinstall:
 	${INSTALL} -o ${BINOWN} -g ${BINGRP} -m ${NOBINMODE} \
 	    ${DIST_DIR}/eign ${DESTDIR}${SHAREDIR}/dict/
diff --git a/gnu/usr.bin/groff/src/utils/lkbib/Makefile b/gnu/usr.bin/groff/src/utils/lkbib/Makefile
index f30dc56..7022aea 100644
--- a/gnu/usr.bin/groff/src/utils/lkbib/Makefile
+++ b/gnu/usr.bin/groff/src/utils/lkbib/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBBIB} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBBIB} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/utils/lookbib/Makefile b/gnu/usr.bin/groff/src/utils/lookbib/Makefile
index 18834a7..7c7b60f 100644
--- a/gnu/usr.bin/groff/src/utils/lookbib/Makefile
+++ b/gnu/usr.bin/groff/src/utils/lookbib/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBBIB} ${LIBGROFF} ${LIBM}
 LDADD=		${LIBBIB} ${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/groff/src/utils/tfmtodit/Makefile b/gnu/usr.bin/groff/src/utils/tfmtodit/Makefile
index ba3bbc5..270682d 100644
--- a/gnu/usr.bin/groff/src/utils/tfmtodit/Makefile
+++ b/gnu/usr.bin/groff/src/utils/tfmtodit/Makefile
@@ -6,4 +6,6 @@ DPADD=		${LIBGROFF} ${LIBM}
 LDADD=		${LIBGROFF} -lm
 CLEANFILES=	${MAN}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/ci/Makefile b/gnu/usr.bin/rcs/ci/Makefile
index 2fbb74f..f22069f 100644
--- a/gnu/usr.bin/rcs/ci/Makefile
+++ b/gnu/usr.bin/rcs/ci/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=	${LIBRCS}
 DPADD=	${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/co/Makefile b/gnu/usr.bin/rcs/co/Makefile
index 0c73865..668e3eca 100644
--- a/gnu/usr.bin/rcs/co/Makefile
+++ b/gnu/usr.bin/rcs/co/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=  ${LIBRCS}
 DPADD=	${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/merge/Makefile b/gnu/usr.bin/rcs/merge/Makefile
index 9022bc4..6d605dc 100644
--- a/gnu/usr.bin/rcs/merge/Makefile
+++ b/gnu/usr.bin/rcs/merge/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=  ${LIBRCS}
 DPADD=  ${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/rcs/Makefile b/gnu/usr.bin/rcs/rcs/Makefile
index aa7cc5f..7dadf10 100644
--- a/gnu/usr.bin/rcs/rcs/Makefile
+++ b/gnu/usr.bin/rcs/rcs/Makefile
@@ -6,5 +6,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=  ${LIBRCS}
 DPADD=  ${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/rcsclean/Makefile b/gnu/usr.bin/rcs/rcsclean/Makefile
index fe538a0..d6bf86f 100644
--- a/gnu/usr.bin/rcs/rcsclean/Makefile
+++ b/gnu/usr.bin/rcs/rcsclean/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=	${LIBRCS}
 DPADD=	${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/rcsdiff/Makefile b/gnu/usr.bin/rcs/rcsdiff/Makefile
index 45ce23f..429bb0a 100644
--- a/gnu/usr.bin/rcs/rcsdiff/Makefile
+++ b/gnu/usr.bin/rcs/rcsdiff/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=  ${LIBRCS}
 DPADD=  ${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/rcsmerge/Makefile b/gnu/usr.bin/rcs/rcsmerge/Makefile
index 9fd8afa..62bfba0 100644
--- a/gnu/usr.bin/rcs/rcsmerge/Makefile
+++ b/gnu/usr.bin/rcs/rcsmerge/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=	${LIBRCS}
 DPADD=	${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/rcs/rlog/Makefile b/gnu/usr.bin/rcs/rlog/Makefile
index bdbf68f..288fc7d 100644
--- a/gnu/usr.bin/rcs/rlog/Makefile
+++ b/gnu/usr.bin/rcs/rlog/Makefile
@@ -4,5 +4,7 @@ CFLAGS+= -I${.CURDIR}/../lib
 LDADD=  ${LIBRCS}
 DPADD=  ${LIBRCS}
 
+NO_PIE=yes
+
 .include "../../Makefile.inc"
 .include <bsd.prog.mk>
diff --git a/gnu/usr.bin/texinfo/info/Makefile b/gnu/usr.bin/texinfo/info/Makefile
index b4e44ac..8c659b2 100644
--- a/gnu/usr.bin/texinfo/info/Makefile
+++ b/gnu/usr.bin/texinfo/info/Makefile
@@ -13,6 +13,8 @@ CFLAGS+= -DINFODIR=\"${INFODIR}:/usr/local/info:.\"
 DPADD=	${LIBTERMCAP} ${LIBTXI}
 LDADD=	-ltermcap ${LIBTXI}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH:	${TXIDIR}/info ${TXIDIR}/doc
diff --git a/gnu/usr.bin/texinfo/infokey/Makefile b/gnu/usr.bin/texinfo/infokey/Makefile
index 50be00d..9433a8b 100644
--- a/gnu/usr.bin/texinfo/infokey/Makefile
+++ b/gnu/usr.bin/texinfo/infokey/Makefile
@@ -6,6 +6,8 @@ SRCS=	infokey.c key.c
 DPADD=	${LIBTXI}
 LDADD=	${LIBTXI}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH:	${TXIDIR}/info ${TXIDIR}/doc
diff --git a/gnu/usr.bin/texinfo/install-info/Makefile b/gnu/usr.bin/texinfo/install-info/Makefile
index 325c909..59eaae0 100644
--- a/gnu/usr.bin/texinfo/install-info/Makefile
+++ b/gnu/usr.bin/texinfo/install-info/Makefile
@@ -5,6 +5,8 @@ PROG=	install-info
 DPADD=	${LIBTXI}
 LDADD=	${LIBTXI}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH:	${TXIDIR}/util ${TXIDIR}/doc
diff --git a/gnu/usr.bin/texinfo/makeinfo/Makefile b/gnu/usr.bin/texinfo/makeinfo/Makefile
index 373c326..87b09db 100644
--- a/gnu/usr.bin/texinfo/makeinfo/Makefile
+++ b/gnu/usr.bin/texinfo/makeinfo/Makefile
@@ -8,6 +8,8 @@ SRCS=	cmds.c defun.c files.c float.c footnote.c html.c \
 DPADD=	${LIBTXI}
 LDADD=	${LIBTXI}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH:	$(TXIDIR)/makeinfo $(TXIDIR)/doc
diff --git a/gnu/usr.bin/texinfo/texindex/Makefile b/gnu/usr.bin/texinfo/texindex/Makefile
index 91c2dfc..c458fec 100644
--- a/gnu/usr.bin/texinfo/texindex/Makefile
+++ b/gnu/usr.bin/texinfo/texindex/Makefile
@@ -5,6 +5,8 @@ PROG=	texindex
 DPADD=	${LIBTXI}
 LDADD=	${LIBTXI}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH:	${TXIDIR}/util ${TXIDIR}/doc
diff --git a/kerberos5/libexec/digest-service/Makefile b/kerberos5/libexec/digest-service/Makefile
index 72f7125..c650135 100644
--- a/kerberos5/libexec/digest-service/Makefile
+++ b/kerberos5/libexec/digest-service/Makefile
@@ -14,6 +14,8 @@ LDADD=	-lhdb -lkdc -lheimipcs -lkrb5 -lroken -lasn1 -lcrypto -lcrypt \
 	${LIBVERS} -lheimntlm
 USEPRIVATELIB= heimipcs
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/libexec/hprop/Makefile b/kerberos5/libexec/hprop/Makefile
index ac1dffa..2ef9964 100644
--- a/kerberos5/libexec/hprop/Makefile
+++ b/kerberos5/libexec/hprop/Makefile
@@ -16,6 +16,8 @@ LDADD=	-lhdb -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/libexec/hpropd/Makefile b/kerberos5/libexec/hpropd/Makefile
index e0722bd..89ba1fd 100644
--- a/kerberos5/libexec/hpropd/Makefile
+++ b/kerberos5/libexec/hpropd/Makefile
@@ -10,6 +10,8 @@ LDADD=	-lhdb -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/libexec/ipropd-master/Makefile b/kerberos5/libexec/ipropd-master/Makefile
index 99a4f9c..98caee2 100644
--- a/kerberos5/libexec/ipropd-master/Makefile
+++ b/kerberos5/libexec/ipropd-master/Makefile
@@ -11,6 +11,8 @@ LDADD=	-lkadm5srv -lhdb -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 foo::
 	echo ${LIBHX509}
 
diff --git a/kerberos5/libexec/ipropd-slave/Makefile b/kerberos5/libexec/ipropd-slave/Makefile
index 8a72d9e..b7d177b 100644
--- a/kerberos5/libexec/ipropd-slave/Makefile
+++ b/kerberos5/libexec/ipropd-slave/Makefile
@@ -11,6 +11,8 @@ LDADD=	-lkadm5srv -lhdb -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/lib/kadm5
diff --git a/kerberos5/libexec/kadmind/Makefile b/kerberos5/libexec/kadmind/Makefile
index f88ac2f..46d54a0 100644
--- a/kerberos5/libexec/kadmind/Makefile
+++ b/kerberos5/libexec/kadmind/Makefile
@@ -15,6 +15,8 @@ LDADD=	-lkadm5srv -lgssapi -lhdb -lkrb5 -lroken \
 	-lasn1 ${LIBVERS} -lcrypto -lcrypt ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kadmin
diff --git a/kerberos5/libexec/kcm/Makefile b/kerberos5/libexec/kcm/Makefile
index bc84c05..89e23a1 100644
--- a/kerberos5/libexec/kcm/Makefile
+++ b/kerberos5/libexec/kcm/Makefile
@@ -26,6 +26,8 @@ LDADD=	-lhdb -lkrb5 -lroken -lasn1 -lheimntlm -lheimipcs \
 USEPRIVATELIB= heimipcs
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kcm
diff --git a/kerberos5/libexec/kdc/Makefile b/kerberos5/libexec/kdc/Makefile
index 4ca5c3a..39c10ef 100644
--- a/kerberos5/libexec/kdc/Makefile
+++ b/kerberos5/libexec/kdc/Makefile
@@ -14,6 +14,8 @@ DPADD=	${LIBKDC} ${LIBHDB} ${LIBKRB5} ${LIBROKEN} ${LIBASN1} \
 	${LIBCRYPTO} ${LIBCRYPT} ${LIBVERS}
 LDADD=	-lkdc -lhdb -lkrb5 -lroken -lasn1 -lcrypto -lcrypt ${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/libexec/kdigest/Makefile b/kerberos5/libexec/kdigest/Makefile
index c88e3b9..5418dca 100644
--- a/kerberos5/libexec/kdigest/Makefile
+++ b/kerberos5/libexec/kdigest/Makefile
@@ -13,6 +13,8 @@ SRCS=	kdigest.c \
 	kdigest-commands.c \
 	kdigest-commands.h
 
+NO_PIE=yes
+
 kdigest-commands.h: kdigest-commands.in
 	${SLC} ${.ALLSRC:M*.in}
 
diff --git a/kerberos5/libexec/kfd/Makefile b/kerberos5/libexec/kfd/Makefile
index f5081f1..a5bcfc3 100644
--- a/kerberos5/libexec/kfd/Makefile
+++ b/kerberos5/libexec/kfd/Makefile
@@ -9,6 +9,8 @@ DPADD=	${LIBKRB5} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO} \
 LDADD=	-lkrb5 -lroken -lasn1 -lcrypto -lcrypt \
 	${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/appl/kf
diff --git a/kerberos5/libexec/kimpersonate/Makefile b/kerberos5/libexec/kimpersonate/Makefile
index 32f9777..72b8646 100644
--- a/kerberos5/libexec/kimpersonate/Makefile
+++ b/kerberos5/libexec/kimpersonate/Makefile
@@ -11,6 +11,8 @@ DPADD=	${LIBKAFS5} ${LIBKRB5} ${LIBHEIMNTLM} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO}
 LDADD=	-lkafs5 -lkrb5 -lheimntlm -lroken -lasn1 -lcrypto -lcrypt \
 	${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kuser
diff --git a/kerberos5/libexec/kpasswdd/Makefile b/kerberos5/libexec/kpasswdd/Makefile
index 2287686..006dafd 100644
--- a/kerberos5/libexec/kpasswdd/Makefile
+++ b/kerberos5/libexec/kpasswdd/Makefile
@@ -9,6 +9,8 @@ LDADD=	-lkadm5srv -lhdb -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kpasswd
diff --git a/kerberos5/tools/asn1_compile/Makefile b/kerberos5/tools/asn1_compile/Makefile
index 88224da..9b46ca9 100644
--- a/kerberos5/tools/asn1_compile/Makefile
+++ b/kerberos5/tools/asn1_compile/Makefile
@@ -27,6 +27,8 @@ CFLAGS+=-I${KRB5DIR}/lib/roken -I${KRB5DIR}/lib/asn1 -I.
 
 CLEANFILES= roken.h lex.c parse.c
 
+NO_PIE=yes
+
 roken.h:
 	 make-roken > ${.TARGET}
 
diff --git a/kerberos5/tools/slc/Makefile b/kerberos5/tools/slc/Makefile
index 1a26e7c..970765e 100644
--- a/kerberos5/tools/slc/Makefile
+++ b/kerberos5/tools/slc/Makefile
@@ -14,6 +14,8 @@ CFLAGS+=-I${KRB5DIR}/lib/roken -I${KRB5DIR}/lib/sl -I${KRB5DIR}/lib/vers -I.
 
 CLEANFILES= roken.h slc-gram.c slc-lex.c
 
+NO_PIE=yes
+
 roken.h:
 	${MAKE_ROKEN} > ${.TARGET}
 
diff --git a/kerberos5/usr.bin/hxtool/Makefile b/kerberos5/usr.bin/hxtool/Makefile
index 3946484..fcc6647 100644
--- a/kerberos5/usr.bin/hxtool/Makefile
+++ b/kerberos5/usr.bin/hxtool/Makefile
@@ -10,6 +10,8 @@ DPADD=	${LIBHX509} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO} ${LIBCRYPT} ${LIBSL} ${LI
 LDADD=	-lhx509 -lroken -lasn1 -lcrypto -lcrypt ${LIBSL} ${LIBVERS} -ledit
 SRCS=	hxtool.c hxtool-commands.c hxtool-commands.h
 
+NO_PIE=yes
+
 hxtool-commands.h: hxtool-commands.in
 	${SLC} ${.ALLSRC:M*.in}
 
diff --git a/kerberos5/usr.bin/kadmin/Makefile b/kerberos5/usr.bin/kadmin/Makefile
index c04ad36..8227b08 100644
--- a/kerberos5/usr.bin/kadmin/Makefile
+++ b/kerberos5/usr.bin/kadmin/Makefile
@@ -36,6 +36,8 @@ LDADD=	-lkadm5clnt -lkadm5srv -lhdb -lkrb5 -lhx509 \
 	-ledit -lncurses ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 kadmin-commands.h: ${KRB5DIR}/kadmin/kadmin-commands.in
diff --git a/kerberos5/usr.bin/kcc/Makefile b/kerberos5/usr.bin/kcc/Makefile
index 3da43d7..94938bc 100644
--- a/kerberos5/usr.bin/kcc/Makefile
+++ b/kerberos5/usr.bin/kcc/Makefile
@@ -19,6 +19,8 @@ SRCS=	kcc.c \
 	kswitch.c \
 	copy_cred_cache.c
 
+NO_PIE=yes
+
 kcc-commands.h: kcc-commands.in
 	${SLC} ${.ALLSRC:M*.in}
 
diff --git a/kerberos5/usr.bin/kdestroy/Makefile b/kerberos5/usr.bin/kdestroy/Makefile
index b3946e4..1ff42ad 100644
--- a/kerberos5/usr.bin/kdestroy/Makefile
+++ b/kerberos5/usr.bin/kdestroy/Makefile
@@ -8,6 +8,8 @@ LDADD=	-lkafs5 -lkrb5 -lheimntlm -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt
 MAN=	kdestroy.1
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kuser
diff --git a/kerberos5/usr.bin/kf/Makefile b/kerberos5/usr.bin/kf/Makefile
index c9d3fce..d2026e2 100644
--- a/kerberos5/usr.bin/kf/Makefile
+++ b/kerberos5/usr.bin/kf/Makefile
@@ -9,6 +9,8 @@ DPADD=	${LIBKRB5} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO} \
 LDADD=	-lkrb5 -lroken -lasn1 -lcrypto -lcrypt \
 	${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/appl/kf
diff --git a/kerberos5/usr.bin/kgetcred/Makefile b/kerberos5/usr.bin/kgetcred/Makefile
index dac38ad..0a4690f 100644
--- a/kerberos5/usr.bin/kgetcred/Makefile
+++ b/kerberos5/usr.bin/kgetcred/Makefile
@@ -6,6 +6,8 @@ CFLAGS+=	-I${KRB5DIR}/lib/asn1 \
 DPADD=	${LIBKRB5} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO} ${LIBCRYPT} ${LIBVERS}
 LDADD=	-lkrb5 -lroken -lasn1 -lcrypto -lcrypt ${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kuser
diff --git a/kerberos5/usr.bin/kinit/Makefile b/kerberos5/usr.bin/kinit/Makefile
index e0229f9..5f7e07f 100644
--- a/kerberos5/usr.bin/kinit/Makefile
+++ b/kerberos5/usr.bin/kinit/Makefile
@@ -7,6 +7,8 @@ DPADD=	${LIBKAFS5} ${LIBKRB5} ${LIBHEIMNTLM} ${LIBROKEN} ${LIBVERS} \
 LDADD=	-lkafs5 -lkrb5 -lheimntlm -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kuser
diff --git a/kerberos5/usr.bin/kpasswd/Makefile b/kerberos5/usr.bin/kpasswd/Makefile
index a9ab1c9..cc880e0 100644
--- a/kerberos5/usr.bin/kpasswd/Makefile
+++ b/kerberos5/usr.bin/kpasswd/Makefile
@@ -7,6 +7,8 @@ DPADD=	${LIBKRB5} ${LIBHX509} ${LIBROKEN} ${LIBVERS} \
 LDADD=	-lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kpasswd
diff --git a/kerberos5/usr.bin/ksu/Makefile b/kerberos5/usr.bin/ksu/Makefile
index 9e27865..25f7879 100644
--- a/kerberos5/usr.bin/ksu/Makefile
+++ b/kerberos5/usr.bin/ksu/Makefile
@@ -13,6 +13,8 @@ DPADD=	${LIBKAFS5} ${LIBKRB5} ${LIBHX509} ${LIBROKEN} ${LIBVERS} \
 LDADD=	-lkafs5 -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/appl/su
diff --git a/kerberos5/usr.bin/string2key/Makefile b/kerberos5/usr.bin/string2key/Makefile
index fc790e2..c39bb92 100644
--- a/kerberos5/usr.bin/string2key/Makefile
+++ b/kerberos5/usr.bin/string2key/Makefile
@@ -11,6 +11,8 @@ DPADD=	${LIBHDB} ${LIBKRB5} ${LIBROKEN} ${LIBASN1} ${LIBCRYPTO} \
 	${LIBCRYPT} ${LIBVERS}
 LDADD=	-lhdb -lkrb5 -lroken -lasn1 -lcrypto -lcrypt ${LIBVERS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/usr.bin/verify_krb5_conf/Makefile b/kerberos5/usr.bin/verify_krb5_conf/Makefile
index 830e66a..5ad339f 100644
--- a/kerberos5/usr.bin/verify_krb5_conf/Makefile
+++ b/kerberos5/usr.bin/verify_krb5_conf/Makefile
@@ -8,6 +8,8 @@ DPADD=	${LIBKAFS5} ${LIBKRB5} ${LIBHX509} ${LIBROKEN} ${LIBVERS} \
 LDADD=	-lkafs5 -lkrb5 -lhx509 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -lcom_err
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/lib/krb5
diff --git a/kerberos5/usr.sbin/iprop-log/Makefile b/kerberos5/usr.sbin/iprop-log/Makefile
index 176012a..f842bb2 100644
--- a/kerberos5/usr.sbin/iprop-log/Makefile
+++ b/kerberos5/usr.sbin/iprop-log/Makefile
@@ -13,6 +13,8 @@ DPADD=	${LIBKADM5SRV} ${LIBHDB} ${LIBKRB5} ${LIBASN1} ${LIBCRYPTO} \
 LDADD=	-lkadm5srv -lhdb -lkrb5 -lasn1 -lcrypto -lcrypt ${LIBSL} -lroken \
 	${LIBVERS} -ledit
 
+NO_PIE=yes
+
 iprop-commands.h: iprop-commands.in
 	${SLC} ${.ALLSRC:M*.in}
 
diff --git a/kerberos5/usr.sbin/kstash/Makefile b/kerberos5/usr.sbin/kstash/Makefile
index 024e45d..a163a5f 100644
--- a/kerberos5/usr.sbin/kstash/Makefile
+++ b/kerberos5/usr.sbin/kstash/Makefile
@@ -10,6 +10,8 @@ LDADD=	-lhdb -lkrb5 -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt ${LDAPLDADD}
 LDFLAGS=${LDAPLDFLAGS}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 .PATH: ${KRB5DIR}/kdc
diff --git a/kerberos5/usr.sbin/ktutil/Makefile b/kerberos5/usr.sbin/ktutil/Makefile
index f7d340f..bcd0214 100644
--- a/kerberos5/usr.sbin/ktutil/Makefile
+++ b/kerberos5/usr.sbin/ktutil/Makefile
@@ -22,6 +22,8 @@ DPADD=	${LIBKADM5CLNT} ${LIBKRB5} ${LIBSL} ${LIBROKEN} ${LIBVERS} \
 LDADD=	-lkadm5clnt -lkrb5 ${LIBSL} -lroken ${LIBVERS} \
 	-lasn1 -lcrypto -lcrypt -ledit
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
 
 ktutil-commands.h: ${KRB5DIR}/admin/ktutil-commands.in
diff --git a/lib/csu/amd64/Makefile b/lib/csu/amd64/Makefile
index 80d14a7..04bed8a 100644
--- a/lib/csu/amd64/Makefile
+++ b/lib/csu/amd64/Makefile
@@ -9,6 +9,8 @@ CFLAGS+=	-I${.CURDIR}/../common \
 		-I${.CURDIR}/../../libc/include
 CFLAGS+=	-fno-omit-frame-pointer
 
+NO_PIE=yes
+
 all: ${OBJS}
 
 CLEANFILES=	${OBJS}
diff --git a/lib/csu/i386-elf/Makefile b/lib/csu/i386-elf/Makefile
index 286c15c..82b21cd 100644
--- a/lib/csu/i386-elf/Makefile
+++ b/lib/csu/i386-elf/Makefile
@@ -13,6 +13,8 @@ CFLAGS+=	-I${.CURDIR}/../common \
 CLEANFILES=	${FILES} crt1_c.o crt1_s.o gcrt1_c.o Scrt1_c.o
 CLEANFILES+=	crt1_c.s gcrt1_c.s Scrt1_c.s
 
+NO_PIE=yes
+
 # See the comment in lib/csu/common/crtbrand.c for the reason crt1_c.c is not
 # directly compiled to .o files.
 
diff --git a/lib/libugidfw/ugidfw.c b/lib/libugidfw/ugidfw.c
index 0dc423d..967c77a 100644
--- a/lib/libugidfw/ugidfw.c
+++ b/lib/libugidfw/ugidfw.c
@@ -36,6 +36,9 @@
 #include <sys/sysctl.h>
 #include <sys/ucred.h>
 #include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
 
 #include <security/mac_bsdextended/mac_bsdextended.h>
 
@@ -44,6 +47,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
 
 #include "ugidfw.h"
 
@@ -329,14 +334,18 @@ bsde_rule_to_string(struct mac_bsdextended_rule *rule, char *buf, size_t buflen)
 			cur += len;
 		}
 		if (rule->mbr_object.mbo_flags & MBO_FSID_DEFINED) {
-			numfs = getmntinfo(&mntbuf, MNT_NOWAIT);
-			for (i = 0; i < numfs; i++)
-				if (memcmp(&(rule->mbr_object.mbo_fsid),
-				    &(mntbuf[i].f_fsid),
-				    sizeof(mntbuf[i].f_fsid)) == 0)
-					break;
-			len = snprintf(cur, left, "filesys %s ", 
-			    i == numfs ? "???" : mntbuf[i].f_mntonname);
+			if (rule->mbr_object.mbo_inode == 0) {
+				numfs = getmntinfo(&mntbuf, MNT_NOWAIT);
+				for (i = 0; i < numfs; i++)
+					if (memcmp(&(rule->mbr_object.mbo_fsid),
+								&(mntbuf[i].f_fsid),
+								sizeof(mntbuf[i].f_fsid)) == 0)
+						break;
+				len = snprintf(cur, left, "filesys %s ", 
+						i == numfs ? "???" : mntbuf[i].f_mntonname);
+			} else {
+				len = snprintf(cur, left, "filesys %s ", rule->mbr_object.mbo_paxpath);
+			}
 			if (len < 0 || len > left)
 				goto truncated;
 			left -= len;
@@ -500,6 +509,50 @@ bsde_rule_to_string(struct mac_bsdextended_rule *rule, char *buf, size_t buflen)
 		cur += len;
 	}
 
+	if (rule->mbr_pax) {
+		len = snprintf(cur, left, " paxflags ");
+		if (len < 0 || len > left)
+			goto truncated;
+		left -= len;
+		cur += len;
+
+		if (rule->mbr_pax & MBI_FORCE_ASLR_ENABLED) {
+			len = snprintf(cur, left, "A");
+			if (len < 0 || len > left)
+				goto truncated;
+
+			left -= len;
+			cur += len;
+		}
+
+		if (rule->mbr_pax & MBI_FORCE_ASLR_DISABLED) {
+			len = snprintf(cur, left, "a");
+			if (len < 0 || len > left)
+				goto truncated;
+
+			left -= len;
+			cur += len;
+		}
+
+		if (rule->mbr_pax & MBI_FORCE_SEGVGUARD_ENABLED) {
+			len = snprintf(cur, left, "S");
+			if (len < 0 || len > left)
+				goto truncated;
+
+			left -= len;
+			cur += len;
+		}
+
+		if (rule->mbr_pax & MBI_FORCE_SEGVGUARD_DISABLED) {
+			len = snprintf(cur, left, "s");
+			if (len < 0 || len > left)
+				goto truncated;
+
+			left -= len;
+			cur += len;
+		}
+	}
+
 	return (0);
 
 truncated:
@@ -507,8 +560,8 @@ truncated:
 }
 
 int
-bsde_parse_uidrange(char *spec, uid_t *min, uid_t *max,
-    size_t buflen, char *errstr){
+bsde_parse_uidrange(char *spec, uid_t *min, uid_t *max, size_t buflen, char *errstr)
+{
 	struct passwd *pwd;
 	uid_t uid1, uid2;
 	char *spec1, *spec2, *endp;
@@ -556,8 +609,8 @@ bsde_parse_uidrange(char *spec, uid_t *min, uid_t *max,
 }
 
 int
-bsde_parse_gidrange(char *spec, gid_t *min, gid_t *max,
-    size_t buflen, char *errstr){
+bsde_parse_gidrange(char *spec, gid_t *min, gid_t *max, size_t buflen, char *errstr)
+{
 	struct group *grp;
 	gid_t gid1, gid2;
 	char *spec1, *spec2, *endp;
@@ -766,19 +819,38 @@ bsde_parse_type(char *spec, int *type, size_t buflen, char *errstr)
 }
 
 int
-bsde_parse_fsid(char *spec, struct fsid *fsid, size_t buflen, char *errstr)
+bsde_parse_fsid(char *spec, struct fsid *fsid, ino_t *inode, size_t buflen, char *errstr)
 {
 	size_t len;
 	struct statfs buf;
+	struct stat sb;
+	int fd, paxstatus;
+	size_t bufsz;
+
+	*inode = 0;
 
 	if (statfs(spec, &buf) < 0) {
 		len = snprintf(errstr, buflen, "Unable to get id for %s: %s",
-		    spec, strerror(errno));
+				spec, strerror(errno));
 		return (-1);
 	}
 
 	*fsid = buf.f_fsid;
 
+	if (strcmp(buf.f_fstypename, "devfs") != 0) {
+		bufsz = sizeof(int);
+		if (!sysctlbyname("security.pax.aslr.status", &paxstatus, &bufsz, NULL, 0)) {
+			fd = open(spec, O_RDONLY);
+			if (fd != -1) {
+				if (fstat(fd, &sb) == 0)
+					if(S_ISDIR(sb.st_mode) == 0)
+						*inode = sb.st_ino;
+
+				close(fd);
+			}
+		}
+	}
+
 	return (0);
 }
 
@@ -852,13 +924,17 @@ bsde_parse_object(int argc, char *argv[],
 				return (-1);
 			}
 			if (bsde_parse_fsid(argv[current+1], &fsid,
-			    buflen, errstr) < 0)
+			    &object->mbo_inode, buflen, errstr) < 0)
 				return (-1);
 			flags |= MBO_FSID_DEFINED;
 			if (nextnot) {
 				neg ^= MBO_FSID_DEFINED;
 				nextnot = 0;
 			}
+			if (object->mbo_inode)
+				snprintf(object->mbo_paxpath, MAXPATHLEN, "%s", argv[current+1]);
+			else
+				memset(object->mbo_paxpath, 0x00, MAXPATHLEN);
 			current += 2;
 		} else if (strcmp(argv[current], "suid") == 0) {
 			flags |= MBO_SUID;
@@ -991,12 +1067,54 @@ bsde_parse_mode(int argc, char *argv[], mode_t *mode, size_t buflen,
 }
 
 int
+bsde_parse_paxflags(int argc, char *argv[], uint32_t *pax, size_t buflen, char *errstr)
+{
+	size_t len;
+	int i;
+
+	if (argc == 0) {
+		len = snprintf(errstr, buflen, "paxflags expects mode value");
+		return (-1);
+	}
+
+	if (argc != 1) {
+		len = snprintf(errstr, buflen, "'%s' unexpected", argv[1]);
+		return (-1);
+	}
+
+	*pax = 0;
+	for (i = 0; i < strlen(argv[0]); i++) {
+		switch (argv[0][i]) {
+		case 'A':
+			*pax |= MBI_FORCE_ASLR_ENABLED;
+			break;
+		case 'a':
+			*pax |= MBI_FORCE_ASLR_DISABLED;
+			break;
+		case 'S':
+			*pax |= MBI_FORCE_SEGVGUARD_ENABLED;
+			break;
+		case 's':
+			*pax |= MBI_FORCE_SEGVGUARD_DISABLED;
+			break;
+		default:
+			len = snprintf(errstr, buflen, "Unknown mode letter: %c",
+					argv[0][i]);
+			return (-1);
+		} 
+	}
+
+	return (0);
+}
+
+int
 bsde_parse_rule(int argc, char *argv[], struct mac_bsdextended_rule *rule,
     size_t buflen, char *errstr)
 {
 	int subject, subject_elements, subject_elements_length;
 	int object, object_elements, object_elements_length;
 	int mode, mode_elements, mode_elements_length;
+	int paxflags, paxflags_elements, paxflags_elements_length=0;
 	int error, i;
 	size_t len;
 
@@ -1037,11 +1155,22 @@ bsde_parse_rule(int argc, char *argv[], struct mac_bsdextended_rule *rule,
 		return (-1);
 	}
 
+	/* Search forward for paxflags */
+	paxflags = -1;
+	for (i = 1; i < argc; i++)
+		if (strcmp(argv[i], "paxflags") == 0)
+			paxflags = i;
+
+	if (paxflags >= 0) {
+		paxflags_elements = paxflags + 1;
+		paxflags_elements_length = argc - paxflags_elements;
+	}
+
 	subject_elements_length = object - subject - 1;
 	object_elements = object + 1;
 	object_elements_length = mode - object_elements;
 	mode_elements = mode + 1;
-	mode_elements_length = argc - mode_elements;
+	mode_elements_length = argc - mode_elements - (paxflags_elements_length ? paxflags_elements_length+1 : 0);
 
 	error = bsde_parse_subject(subject_elements_length,
 	    argv + subject_elements, &rule->mbr_subject, buflen, errstr);
@@ -1058,6 +1187,13 @@ bsde_parse_rule(int argc, char *argv[], struct mac_bsdextended_rule *rule,
 	if (error)
 		return (-1);
 
+	if (paxflags >= 0) {
+		error = bsde_parse_paxflags(paxflags_elements_length, argv + paxflags_elements,
+				&rule->mbr_pax, buflen, errstr);
+		if (error)
+			return (-1);
+	}
+
 	return (0);
 }
 
diff --git a/lib/libugidfw/ugidfw.h b/lib/libugidfw/ugidfw.h
index 5b7fcf2..cef469c 100644
--- a/lib/libugidfw/ugidfw.h
+++ b/lib/libugidfw/ugidfw.h
@@ -39,6 +39,8 @@ int	bsde_rule_to_string(struct mac_bsdextended_rule *rule, char *buf,
 	    size_t buflen);
 int	bsde_parse_mode(int argc, char *argv[], mode_t *mode, size_t buflen,
 	    char *errstr);
+int	bsde_parse_paxflags(int argc, char *argv[], uint32_t *pax, size_t buflen,
+	    char *errstr);
 int	bsde_parse_rule(int argc, char *argv[],
 	    struct mac_bsdextended_rule *rule, size_t buflen, char *errstr);
 int	bsde_parse_rule_string(const char *string,
diff --git a/libexec/mail.local/Makefile b/libexec/mail.local/Makefile
index 3e59609..2254ca0 100644
--- a/libexec/mail.local/Makefile
+++ b/libexec/mail.local/Makefile
@@ -9,6 +9,8 @@ SRCS=	mail.local.c
 MAN=	mail.local.8
 CFLAGS+=-I${SENDMAIL_DIR}/include -I.
 
+NO_PIE=yes
+
 WARNS?=	2
 WFORMAT=0
 
diff --git a/libexec/rtld-elf/Makefile b/libexec/rtld-elf/Makefile
index 21e2219..b675e6f 100644
--- a/libexec/rtld-elf/Makefile
+++ b/libexec/rtld-elf/Makefile
@@ -78,5 +78,7 @@ beforeinstall:
 
 .PATH: ${.CURDIR}/${RTLD_ARCH}
 
+NO_PIE=yes
+
 .include <bsd.symver.mk>
 .include <bsd.prog.mk>
diff --git a/libexec/rtld-elf/rtld.c b/libexec/rtld-elf/rtld.c
index 443767d..ed732ae 100644
--- a/libexec/rtld-elf/rtld.c
+++ b/libexec/rtld-elf/rtld.c
@@ -864,7 +864,7 @@ digest_dynamic1(Obj_Entry *obj, int early, const Elf_Dyn **dyn_rpath,
     const Elf_Hashelt *hashtab;
     const Elf32_Word *hashval;
     Elf32_Word bkt, nmaskwords;
-    int bloom_size32;
+    unsigned int bloom_size32;
     bool nmw_power2;
     int plttype = DT_REL;
 
diff --git a/libexec/smrsh/Makefile b/libexec/smrsh/Makefile
index ae86155..9aafae8 100644
--- a/libexec/smrsh/Makefile
+++ b/libexec/smrsh/Makefile
@@ -9,6 +9,8 @@ SRCS=	smrsh.c
 MAN=	smrsh.8
 CFLAGS+=-I${SENDMAIL_DIR}/src -I${SENDMAIL_DIR}/include -I.
 
+NO_PIE=yes
+
 LIBSMDIR=	${.OBJDIR}/../../lib/libsm
 LIBSM=		${LIBSMDIR}/libsm.a
 
diff --git a/libexec/telnetd/Makefile b/libexec/telnetd/Makefile
index 99f023f..35c0e74 100644
--- a/libexec/telnetd/Makefile
+++ b/libexec/telnetd/Makefile
@@ -20,6 +20,8 @@ WFORMAT?=	0
 CFLAGS+=	-DLINEMODE -DUSE_TERMIO -DDIAGNOSTICS -DOLD_ENVIRON \
 		-DENV_HACK -DSTREAMSPTY
 
+NO_PIE=yes
+
 .if ${MK_INET6_SUPPORT} != "no"
 CFLAGS+=	-DINET6
 .endif
diff --git a/release/Makefile b/release/Makefile
index 92075f8..736d6d2 100644
--- a/release/Makefile
+++ b/release/Makefile
@@ -31,6 +31,7 @@ PORTSDIR?=	/usr/ports
 DOCDIR?=	/usr/doc
 RELNOTES_LANG?= en_US.ISO8859-1
 XZCMD?=		/usr/bin/xz
+KERNCONF?=	GENERIC
 
 .if !defined(TARGET) || empty(TARGET)
 TARGET=		${MACHINE}
@@ -120,7 +121,8 @@ base.txz:
 
 kernel.txz:
 	mkdir -p ${DISTDIR}
-	cd ${WORLDDIR} && ${IMAKE} distributekernel packagekernel DISTDIR=${.OBJDIR}/${DISTDIR}
+	cd ${WORLDDIR} && ${IMAKE} distributekernel packagekernel \
+		DISTDIR=${.OBJDIR}/${DISTDIR} KERNCONF=${KERNCONF}
 	mv ${DISTDIR}/kernel*.txz .
 
 src.txz:
@@ -152,7 +154,8 @@ system: packagesystem
 	mkdir -p release
 	cd ${WORLDDIR} && ${IMAKE} installkernel installworld distribution \
 		DESTDIR=${.OBJDIR}/release WITHOUT_RESCUE=1 WITHOUT_KERNEL_SYMBOLS=1 \
-		WITHOUT_PROFILE=1 WITHOUT_SENDMAIL=1 WITHOUT_ATF=1 WITHOUT_LIB32=1
+		WITHOUT_PROFILE=1 WITHOUT_SENDMAIL=1 WITHOUT_ATF=1 WITHOUT_LIB32=1 \
+		KERNCONF=${KERNCONF}
 # Copy distfiles
 	mkdir -p release/usr/freebsd-dist
 	cp *.txz MANIFEST release/usr/freebsd-dist
@@ -177,7 +180,7 @@ bootonly: packagesystem
 	    WITHOUT_INSTALLLIB=1 WITHOUT_LIB32=1 WITHOUT_MAIL=1 \
 	    WITHOUT_NCP=1 WITHOUT_TOOLCHAIN=1 WITHOUT_PROFILE=1 \
 	    WITHOUT_INSTALLIB=1 WITHOUT_RESCUE=1 WITHOUT_DICT=1 \
-	    WITHOUT_KERNEL_SYMBOLS=1
+	    WITHOUT_KERNEL_SYMBOLS=1 KERNCONF=${KERNCONF}
 # Copy manifest only (no distfiles) to get checksums
 	mkdir -p bootonly/usr/freebsd-dist
 	cp MANIFEST bootonly/usr/freebsd-dist
@@ -196,7 +199,8 @@ dvd:
 # Install system
 	mkdir -p ${.TARGET}
 	cd ${WORLDDIR} && ${IMAKE} installkernel installworld distribution \
-		DESTDIR=${.OBJDIR}/${.TARGET} WITHOUT_RESCUE=1 WITHOUT_KERNEL_SYMBOLS=1
+		DESTDIR=${.OBJDIR}/${.TARGET} WITHOUT_RESCUE=1 WITHOUT_KERNEL_SYMBOLS=1 \
+		KERNCONF=${KERNCONF}
 # Copy distfiles
 	mkdir -p ${.TARGET}/usr/freebsd-dist
 	cp *.txz MANIFEST ${.TARGET}/usr/freebsd-dist
diff --git a/sbin/fsck/Makefile b/sbin/fsck/Makefile
index 22de03c..a85bc71 100644
--- a/sbin/fsck/Makefile
+++ b/sbin/fsck/Makefile
@@ -5,4 +5,6 @@ PROG=	fsck
 SRCS=	fsck.c fsutil.c preen.c
 MAN=	fsck.8
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/sbin/ipf/ipf/Makefile b/sbin/ipf/ipf/Makefile
index c3938c6..116652e 100644
--- a/sbin/ipf/ipf/Makefile
+++ b/sbin/ipf/ipf/Makefile
@@ -39,4 +39,6 @@ DPADD+=	${LIBPCAP}
 LDADD+=	-lpcap
 .endif
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/sbin/ipf/ipfstat/Makefile b/sbin/ipf/ipfstat/Makefile
index a33c5df..6d5b796 100644
--- a/sbin/ipf/ipfstat/Makefile
+++ b/sbin/ipf/ipfstat/Makefile
@@ -8,4 +8,6 @@ MAN=		ipfstat.8
 DPADD+=  	${LIBCURSES}
 LDADD+=  	-lcurses
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/sbin/ipf/ipftest/Makefile b/sbin/ipf/ipftest/Makefile
index 32b074c..7827562 100644
--- a/sbin/ipf/ipftest/Makefile
+++ b/sbin/ipf/ipftest/Makefile
@@ -32,6 +32,8 @@ CLEANFILES+=	ipnat.tab.c ipnat.tab.h
 CLEANFILES+=	ippool_y.c ippool_l.c
 CLEANFILES+=	ippool.tab.c ippool.tab.h
 
+NO_PIE=yes
+
 ipnat_y.c: ipnat_y.y
 	${YACC} -b ipnat -d ${.ALLSRC}
 	sed -e 's/yy/ipnat_yy/g' \
diff --git a/sbin/ipf/ipmon/Makefile b/sbin/ipf/ipmon/Makefile
index 3639f87..36db06c 100644
--- a/sbin/ipf/ipmon/Makefile
+++ b/sbin/ipf/ipmon/Makefile
@@ -11,6 +11,8 @@ DPSRCS+=	${GENHDRS}
 
 CLEANFILES+=	${GENHDRS} ipmon_y.c ipmon_l.c
 
+NO_PIE=yes
+
 ipmon_y.c: ipmon_y.y
 	${YACC} -d ${.ALLSRC}
 	sed -e 's/yy/ipmon_yy/g' \
diff --git a/sbin/ipf/ipnat/Makefile b/sbin/ipf/ipnat/Makefile
index 1c017e1..c53e86a 100644
--- a/sbin/ipf/ipnat/Makefile
+++ b/sbin/ipf/ipnat/Makefile
@@ -11,6 +11,8 @@ DPSRCS+=	${GENHDRS}
 
 CLEANFILES+=	${GENHDRS} ipnat_y.c ipnat_l.c
 
+NO_PIE=yes
+
 ipnat_y.c: ipnat_y.y
 	${YACC} -d ${.ALLSRC}
 	sed -e 's/yy/ipnat_yy/g' \
diff --git a/sbin/ipf/ippool/Makefile b/sbin/ipf/ippool/Makefile
index 6e3f85d..3bd0282 100644
--- a/sbin/ipf/ippool/Makefile
+++ b/sbin/ipf/ippool/Makefile
@@ -10,6 +10,8 @@ DPSRCS+=	${GENHDRS}
 
 CLEANFILES+=	${GENHDRS} ippool_y.c ippool_l.c
 
+NO_PIE=yes
+
 ippool_y.c: ippool_y.y
 	${YACC} -d ${.ALLSRC}
 	sed -e 's/yy/ippool_yy/g' \
diff --git a/sbin/ipf/ipresend/Makefile b/sbin/ipf/ipresend/Makefile
index 5e0ac15..56f1d0d 100644
--- a/sbin/ipf/ipresend/Makefile
+++ b/sbin/ipf/ipresend/Makefile
@@ -4,6 +4,8 @@ PROG=		ipresend
 SRCS=		ipresend.c ip.c resend.c sbpf.c sock.c 44arp.c
 MAN=		ipresend.1
 
+NO_PIE=yes
+
 .PATH:		${.CURDIR}/../../../contrib/ipfilter/ipsend
 
 .include <bsd.prog.mk>
diff --git a/sbin/rcorder/Makefile b/sbin/rcorder/Makefile
index b71aa4b..3078f10 100644
--- a/sbin/rcorder/Makefile
+++ b/sbin/rcorder/Makefile
@@ -14,6 +14,8 @@ CFLAGS+= -DORDER -I.
 SRCS+=	util.h
 CLEANFILES+=	util.h
 
+NO_PIE=yes
+
 util.h:
 	ln -sf ${.CURDIR}/../../lib/libutil/libutil.h ${.TARGET}
 
diff --git a/share/mk/bsd.opts.mk b/share/mk/bsd.opts.mk
index 51d6c03..6b5ad51 100644
--- a/share/mk/bsd.opts.mk
+++ b/share/mk/bsd.opts.mk
@@ -68,7 +68,8 @@ __DEFAULT_YES_OPTIONS = \
 __DEFAULT_NO_OPTIONS = \
     CTF \
     DEBUG_FILES \
-    INSTALL_AS_USER
+    INSTALL_AS_USER \
+    PIE
 
 .include <bsd.mkopt.mk>
 
diff --git a/share/mk/bsd.prog.mk b/share/mk/bsd.prog.mk
index fd35e03..229ce8e 100644
--- a/share/mk/bsd.prog.mk
+++ b/share/mk/bsd.prog.mk
@@ -11,6 +11,18 @@
 CFLAGS+=${COPTS}
 .endif
 
+.if ${MK_PIE} != "no" && (!defined(NO_PIE) || ${NO_PIE} == "no")
+.if !defined(RESCUE) && !defined(NO_SHARED)
+CFLAGS+= -fPIE -pie
+LDFLAGS+= -pie
+.elif defined(NO_SHARED)
+.if ${NO_SHARED} == "no" || ${NO_SHARED} == "NO"
+CFLAGS+= -fPIE -pie
+LDFLAGS+= -pie
+.endif
+.endif
+.endif
+
 .if ${MK_ASSERT_DEBUG} == "no"
 CFLAGS+= -DNDEBUG
 NO_WERROR=
diff --git a/sys/amd64/amd64/elf_machdep.c b/sys/amd64/amd64/elf_machdep.c
index fdc4d56..ffb5e31 100644
--- a/sys/amd64/amd64/elf_machdep.c
+++ b/sys/amd64/amd64/elf_machdep.c
@@ -26,12 +26,17 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
 #include <sys/exec.h>
 #include <sys/imgact.h>
 #include <sys/linker.h>
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
 #include <sys/proc.h>
 #include <sys/sysent.h>
 #include <sys/imgact_elf.h>
@@ -81,6 +86,11 @@ struct sysentvec elf64_freebsd_sysvec = {
 	.sv_shared_page_base = SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf64_sysvec, &elf64_freebsd_sysvec);
 
diff --git a/sys/amd64/conf/LATT-ASLR b/sys/amd64/conf/LATT-ASLR
new file mode 100644
index 0000000..d3ed921
--- /dev/null
+++ b/sys/amd64/conf/LATT-ASLR
@@ -0,0 +1,359 @@
+#
+# GENERIC -- Generic kernel configuration file for FreeBSD/amd64
+#
+# For more information on this file, please read the config(5) manual page,
+# and/or the handbook section on Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files.
+# If you are in doubt as to the purpose or necessity of a line, check first
+# in NOTES.
+#
+# $FreeBSD$
+
+cpu		HAMMER
+ident		GENERIC
+
+makeoptions	DEBUG=-g
+makeoptions	WITH_CTF=1		# Run ctfconvert(1) for DTrace support
+
+options 	SCHED_ULE		# ULE scheduler
+options 	PREEMPTION		# Enable kernel thread preemption
+options 	INET			# InterNETworking
+options 	INET6			# IPv6 communications protocols
+options 	TCP_OFFLOAD		# TCP offload
+options 	SCTP			# Stream Control Transmission Protocol
+options 	FFS			# Berkeley Fast Filesystem
+options 	SOFTUPDATES		# Enable FFS soft updates support
+options 	UFS_ACL			# Support for access control lists
+options 	UFS_DIRHASH		# Improve performance on big directories
+options 	UFS_GJOURNAL		# Enable gjournal-based UFS journaling
+options 	QUOTA			# Enable disk quotas for UFS
+options 	MD_ROOT			# MD is a potential root device
+options 	NFSCL			# New Network Filesystem Client
+options 	NFSD			# New Network Filesystem Server
+options 	NFSLOCKD		# Network Lock Manager
+options 	NFS_ROOT		# NFS usable as /, requires NFSCL
+options 	MSDOSFS			# MSDOS Filesystem
+options 	CD9660			# ISO 9660 Filesystem
+options 	PROCFS			# Process filesystem (requires PSEUDOFS)
+options 	PSEUDOFS		# Pseudo-filesystem framework
+options 	GEOM_PART_GPT		# GUID Partition Tables.
+options 	GEOM_RAID		# Soft RAID functionality.
+options 	GEOM_LABEL		# Provides labelization
+options 	COMPAT_FREEBSD32	# Compatible with i386 binaries
+options 	COMPAT_FREEBSD4		# Compatible with FreeBSD4
+options 	COMPAT_FREEBSD5		# Compatible with FreeBSD5
+options 	COMPAT_FREEBSD6		# Compatible with FreeBSD6
+options 	COMPAT_FREEBSD7		# Compatible with FreeBSD7
+options 	SCSI_DELAY=5000		# Delay (in ms) before probing SCSI
+options 	KTRACE			# ktrace(1) support
+options 	STACK			# stack(9) support
+options 	SYSVSHM			# SYSV-style shared memory
+options 	SYSVMSG			# SYSV-style message queues
+options 	SYSVSEM			# SYSV-style semaphores
+options 	_KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
+options 	PRINTF_BUFR_SIZE=128	# Prevent printf output being interspersed.
+options 	KBD_INSTALL_CDEV	# install a CDEV entry in /dev
+options 	HWPMC_HOOKS		# Necessary kernel hooks for hwpmc(4)
+options 	AUDIT			# Security event auditing
+options 	CAPABILITY_MODE		# Capsicum capability mode
+options 	CAPABILITIES		# Capsicum capabilities
+options 	MAC			# TrustedBSD MAC Framework
+options 	KDTRACE_FRAME		# Ensure frames are compiled in
+options 	KDTRACE_HOOKS		# Kernel DTrace hooks
+options 	DDB_CTF			# Kernel ELF linker loads CTF data
+options 	INCLUDE_CONFIG_FILE	# Include this file in kernel
+
+# Debugging support.  Always need this:
+options 	KDB			# Enable kernel debugger support.
+options 	KDB_TRACE		# Print a stack trace for a panic.
+# For full debugger support use (turn off in stable branch):
+options 	DDB			# Support DDB.
+options 	GDB			# Support remote GDB.
+options 	DEADLKRES		# Enable the deadlock resolver
+#options 	INVARIANTS		# Enable calls of extra sanity checking
+#options 	INVARIANT_SUPPORT	# Extra sanity checks of internal structures, required by INVARIANTS
+#options 	WITNESS			# Enable checks to detect deadlocks and cycles
+#options 	WITNESS_SKIPSPIN	# Don't run witness on spinlocks for speed
+options 	MALLOC_DEBUG_MAXZONES=8	# Separate malloc(9) zones
+
+# Make an SMP-capable kernel by default
+options 	SMP			# Symmetric MultiProcessor Kernel
+
+# CPU frequency control
+device		cpufreq
+
+# Bus support.
+device		acpi
+options 	ACPI_DMAR
+device		pci
+
+# Floppy drives
+device		fdc
+
+# ATA controllers
+device		ahci			# AHCI-compatible SATA controllers
+device		ata			# Legacy ATA/SATA controllers
+options 	ATA_STATIC_ID		# Static device numbering
+device		mvs			# Marvell 88SX50XX/88SX60XX/88SX70XX/SoC SATA
+device		siis			# SiliconImage SiI3124/SiI3132/SiI3531 SATA
+
+# SCSI Controllers
+device		ahc			# AHA2940 and onboard AIC7xxx devices
+options 	AHC_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~128k to driver.
+device		ahd			# AHA39320/29320 and onboard AIC79xx devices
+options 	AHD_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~215k to driver.
+device		esp			# AMD Am53C974 (Tekram DC-390(T))
+device		hptiop			# Highpoint RocketRaid 3xxx series
+device		isp			# Qlogic family
+#device		ispfw			# Firmware for QLogic HBAs- normally a module
+device		mpt			# LSI-Logic MPT-Fusion
+device		mps			# LSI-Logic MPT-Fusion 2
+device		mpr			# LSI-Logic MPT-Fusion 3
+#device		ncr			# NCR/Symbios Logic
+device		sym			# NCR/Symbios Logic (newer chipsets + those of `ncr')
+device		trm			# Tekram DC395U/UW/F DC315U adapters
+
+device		adv			# Advansys SCSI adapters
+device		adw			# Advansys wide SCSI adapters
+device		aic			# Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
+device		bt			# Buslogic/Mylex MultiMaster SCSI adapters
+device		isci			# Intel C600 SAS controller
+
+# ATA/SCSI peripherals
+device		scbus			# SCSI bus (required for ATA/SCSI)
+device		ch			# SCSI media changers
+device		da			# Direct Access (disks)
+device		sa			# Sequential Access (tape etc)
+device		cd			# CD
+device		pass			# Passthrough device (direct ATA/SCSI access)
+device		ses			# Enclosure Services (SES and SAF-TE)
+#device		ctl			# CAM Target Layer
+
+# RAID controllers interfaced to the SCSI subsystem
+device		amr			# AMI MegaRAID
+device		arcmsr			# Areca SATA II RAID
+#XXX it is not 64-bit clean, -scottl
+#device		asr			# DPT SmartRAID V, VI and Adaptec SCSI RAID
+device		ciss			# Compaq Smart RAID 5*
+device		dpt			# DPT Smartcache III, IV - See NOTES for options
+device		hptmv			# Highpoint RocketRAID 182x
+device		hptnr			# Highpoint DC7280, R750
+device		hptrr			# Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
+device		hpt27xx			# Highpoint RocketRAID 27xx
+device		iir			# Intel Integrated RAID
+device		ips			# IBM (Adaptec) ServeRAID
+device		mly			# Mylex AcceleRAID/eXtremeRAID
+device		twa			# 3ware 9000 series PATA/SATA RAID
+device		tws			# LSI 3ware 9750 SATA+SAS 6Gb/s RAID controller
+
+# RAID controllers
+device		aac			# Adaptec FSA RAID
+device		aacp			# SCSI passthrough for aac (requires CAM)
+device		aacraid			# Adaptec by PMC RAID
+device		ida			# Compaq Smart RAID
+device		mfi			# LSI MegaRAID SAS
+device		mlx			# Mylex DAC960 family
+#XXX pointer/int warnings
+#device		pst			# Promise Supertrak SX6000
+device		twe			# 3ware ATA RAID
+
+# atkbdc0 controls both the keyboard and the PS/2 mouse
+device		atkbdc			# AT keyboard controller
+device		atkbd			# AT keyboard
+device		psm			# PS/2 mouse
+
+device		kbdmux			# keyboard multiplexer
+
+device		vga			# VGA video card driver
+options 	VESA			# Add support for VESA BIOS Extensions (VBE)
+
+device		splash			# Splash screen and screen saver support
+
+# syscons is the default console driver, resembling an SCO console
+device		sc
+options 	SC_PIXEL_MODE		# add support for the raster text mode
+
+device		agp			# support several AGP chipsets
+
+# PCCARD (PCMCIA) support
+# PCMCIA and cardbus bridge support
+device		cbb			# cardbus (yenta) bridge
+device		pccard			# PC Card (16-bit) bus
+device		cardbus			# CardBus (32-bit) bus
+
+# Serial (COM) ports
+device		uart			# Generic UART driver
+
+# Parallel port
+device		ppc
+device		ppbus			# Parallel port bus (required)
+device		lpt			# Printer
+device		ppi			# Parallel port interface device
+#device		vpo			# Requires scbus and da
+
+device		puc			# Multi I/O cards and multi-channel UARTs
+
+# PCI Ethernet NICs.
+device		bxe			# Broadcom NetXtreme II BCM5771X/BCM578XX 10GbE
+device		de			# DEC/Intel DC21x4x (``Tulip'')
+device		em			# Intel PRO/1000 Gigabit Ethernet Family
+device		igb			# Intel PRO/1000 PCIE Server Gigabit Family
+device		ixgbe			# Intel PRO/10GbE PCIE Ethernet Family
+device		le			# AMD Am7900 LANCE and Am79C9xx PCnet
+device		ti			# Alteon Networks Tigon I/II gigabit Ethernet
+device		txp			# 3Com 3cR990 (``Typhoon'')
+device		vx			# 3Com 3c590, 3c595 (``Vortex'')
+
+# PCI Ethernet NICs that use the common MII bus controller code.
+# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
+device		miibus			# MII bus support
+device		ae			# Attansic/Atheros L2 FastEthernet
+device		age			# Attansic/Atheros L1 Gigabit Ethernet
+device		alc			# Atheros AR8131/AR8132 Ethernet
+device		ale			# Atheros AR8121/AR8113/AR8114 Ethernet
+device		bce			# Broadcom BCM5706/BCM5708 Gigabit Ethernet
+device		bfe			# Broadcom BCM440x 10/100 Ethernet
+device		bge			# Broadcom BCM570xx Gigabit Ethernet
+device		cas			# Sun Cassini/Cassini+ and NS DP83065 Saturn
+device		dc			# DEC/Intel 21143 and various workalikes
+device		et			# Agere ET1310 10/100/Gigabit Ethernet
+device		fxp			# Intel EtherExpress PRO/100B (82557, 82558)
+device		gem			# Sun GEM/Sun ERI/Apple GMAC
+device		hme			# Sun HME (Happy Meal Ethernet)
+device		jme			# JMicron JMC250 Gigabit/JMC260 Fast Ethernet
+device		lge			# Level 1 LXT1001 gigabit Ethernet
+device		msk			# Marvell/SysKonnect Yukon II Gigabit Ethernet
+device		nfe			# nVidia nForce MCP on-board Ethernet
+device		nge			# NatSemi DP83820 gigabit Ethernet
+device		pcn			# AMD Am79C97x PCI 10/100 (precedence over 'le')
+device		re			# RealTek 8139C+/8169/8169S/8110S
+device		rl			# RealTek 8129/8139
+device		sf			# Adaptec AIC-6915 (``Starfire'')
+device		sge			# Silicon Integrated Systems SiS190/191
+device		sis			# Silicon Integrated Systems SiS 900/SiS 7016
+device		sk			# SysKonnect SK-984x & SK-982x gigabit Ethernet
+device		ste			# Sundance ST201 (D-Link DFE-550TX)
+device		stge			# Sundance/Tamarack TC9021 gigabit Ethernet
+device		tl			# Texas Instruments ThunderLAN
+device		tx			# SMC EtherPower II (83c170 ``EPIC'')
+device		vge			# VIA VT612x gigabit Ethernet
+device		vr			# VIA Rhine, Rhine II
+device		wb			# Winbond W89C840F
+device		xl			# 3Com 3c90x (``Boomerang'', ``Cyclone'')
+
+# ISA Ethernet NICs.  pccard NICs included.
+device		cs			# Crystal Semiconductor CS89x0 NIC
+# 'device ed' requires 'device miibus'
+device		ed			# NE[12]000, SMC Ultra, 3c503, DS8390 cards
+device		ex			# Intel EtherExpress Pro/10 and Pro/10+
+device		ep			# Etherlink III based cards
+device		fe			# Fujitsu MB8696x based cards
+device		sn			# SMC's 9000 series of Ethernet chips
+device		xe			# Xircom pccard Ethernet
+
+# Wireless NIC cards
+device		wlan			# 802.11 support
+options 	IEEE80211_DEBUG		# enable debug msgs
+options 	IEEE80211_AMPDU_AGE	# age frames in AMPDU reorder q's
+options 	IEEE80211_SUPPORT_MESH	# enable 802.11s draft support
+device		wlan_wep		# 802.11 WEP support
+device		wlan_ccmp		# 802.11 CCMP support
+device		wlan_tkip		# 802.11 TKIP support
+device		wlan_amrr		# AMRR transmit rate control algorithm
+device		an			# Aironet 4500/4800 802.11 wireless NICs.
+device		ath			# Atheros NICs
+device		ath_pci			# Atheros pci/cardbus glue
+device		ath_hal			# pci/cardbus chip support
+options 	AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
+options 	AH_AR5416_INTERRUPT_MITIGATION # AR5416 interrupt mitigation
+options 	ATH_ENABLE_11N		# Enable 802.11n support for AR5416 and later
+device		ath_rate_sample		# SampleRate tx rate control for ath
+#device		bwi			# Broadcom BCM430x/BCM431x wireless NICs.
+#device		bwn			# Broadcom BCM43xx wireless NICs.
+device		ipw			# Intel 2100 wireless NICs.
+device		iwi			# Intel 2200BG/2225BG/2915ABG wireless NICs.
+device		iwn			# Intel 4965/1000/5000/6000 wireless NICs.
+device		malo			# Marvell Libertas wireless NICs.
+device		mwl			# Marvell 88W8363 802.11n wireless NICs.
+device		ral			# Ralink Technology RT2500 wireless NICs.
+device		wi			# WaveLAN/Intersil/Symbol 802.11 wireless NICs.
+device		wpi			# Intel 3945ABG wireless NICs.
+
+# Pseudo devices.
+device		loop			# Network loopback
+device		random			# Entropy device
+device		padlock_rng		# VIA Padlock RNG
+device		rdrand_rng		# Intel Bull Mountain RNG
+device		ether			# Ethernet support
+device		vlan			# 802.1Q VLAN support
+device		tun			# Packet tunnel.
+device		md			# Memory "disks"
+device		gif			# IPv6 and IPv4 tunneling
+device		faith			# IPv6-to-IPv4 relaying (translation)
+device		firmware		# firmware assist module
+
+# The `bpf' device enables the Berkeley Packet Filter.
+# Be aware of the administrative consequences of enabling this!
+# Note that 'bpf' is required for DHCP.
+device		bpf			# Berkeley packet filter
+
+# USB support
+options 	USB_DEBUG		# enable debug msgs
+device		uhci			# UHCI PCI->USB interface
+device		ohci			# OHCI PCI->USB interface
+device		ehci			# EHCI PCI->USB interface (USB 2.0)
+device		xhci			# XHCI PCI->USB interface (USB 3.0)
+device		usb			# USB Bus (required)
+device		ukbd			# Keyboard
+device		umass			# Disks/Mass storage - Requires scbus and da
+
+# Sound support
+device		sound			# Generic sound driver (required)
+device		snd_cmi			# CMedia CMI8338/CMI8738
+device		snd_csa			# Crystal Semiconductor CS461x/428x
+device		snd_emu10kx		# Creative SoundBlaster Live! and Audigy
+device		snd_es137x		# Ensoniq AudioPCI ES137x
+device		snd_hda			# Intel High Definition Audio
+device		snd_ich			# Intel, NVidia and other ICH AC'97 Audio
+device		snd_via8233		# VIA VT8233x Audio
+
+# MMC/SD
+device		mmc			# MMC/SD bus
+device		mmcsd			# MMC/SD memory card
+device		sdhci			# Generic PCI SD Host Controller
+
+# VirtIO support
+device		virtio			# Generic VirtIO bus (required)
+device		virtio_pci		# VirtIO PCI device
+device		vtnet			# VirtIO Ethernet device
+device		virtio_blk		# VirtIO Block device
+device		virtio_scsi		# VirtIO SCSI device
+device		virtio_balloon		# VirtIO Memory Balloon device
+
+# HyperV drivers
+device		hyperv			# HyperV drivers 
+
+# Xen HVM Guest Optimizations
+# NOTE: XENHVM depends on xenpci.  They must be added or removed together.
+options 	XENHVM			# Xen HVM kernel infrastructure
+device		xenpci			# Xen HVM Hypervisor services driver
+
+# VMware support
+device		vmx			# VMware VMXNET3 Ethernet
+
+options PAX_ASLR
+#options PAX_SEGVGUARD
+
+options VIMAGE
+options GEOM_PART_VTOC8
diff --git a/sys/amd64/conf/OP-ASLR b/sys/amd64/conf/OP-ASLR
new file mode 100644
index 0000000..cc6de36
--- /dev/null
+++ b/sys/amd64/conf/OP-ASLR
@@ -0,0 +1,388 @@
+#
+# GENERIC -- Generic kernel configuration file for FreeBSD/amd64
+#
+# For more information on this file, please read the config(5) manual page,
+# and/or the handbook section on Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files.
+# If you are in doubt as to the purpose or necessity of a line, check first
+# in NOTES.
+#
+# $FreeBSD$
+
+cpu		HAMMER
+ident		OP-PERPETUA
+
+options		HZ=100
+
+makeoptions	DEBUG=-gdwarf-2		# Build kernel with gdb(1) debug symbols
+makeoptions	MODULES_OVERRIDE="geom/geom_sched linux"
+#makeoptions	WITH_CTF=1		# Run ctfconvert(1) for DTrace support
+
+options 	SCHED_ULE		# ULE scheduler
+#options 	PREEMPTION		# Enable kernel thread preemption
+options 	INET			# InterNETworking
+options 	INET6			# IPv6 communications protocols
+options 	TCP_OFFLOAD		# TCP offload
+#options 	SCTP			# Stream Control Transmission Protocol
+options 	FFS			# Berkeley Fast Filesystem
+options 	SOFTUPDATES		# Enable FFS soft updates support
+options 	UFS_ACL			# Support for access control lists
+options 	UFS_DIRHASH		# Improve performance on big directories
+options		UFS_EXTATTR
+#options 	UFS_GJOURNAL		# Enable gjournal-based UFS journaling
+options 	QUOTA			# Enable disk quotas for UFS
+#options 	MD_ROOT			# MD is a potential root device
+#options 	NFSCL			# New Network Filesystem Client
+#options 	NFSD			# New Network Filesystem Server
+#options 	NFSLOCKD		# Network Lock Manager
+#options 	NFS_ROOT		# NFS usable as /, requires NFSCL
+#options 	MSDOSFS			# MSDOS Filesystem
+#options 	CD9660			# ISO 9660 Filesystem
+#options 	PROCFS			# Process filesystem (requires PSEUDOFS)
+options 	PSEUDOFS		# Pseudo-filesystem framework
+options 	GEOM_PART_GPT		# GUID Partition Tables.
+options 	GEOM_RAID		# Soft RAID functionality.
+options 	GEOM_LABEL		# Provides labelization
+options 	COMPAT_FREEBSD32	# Compatible with i386 binaries
+options 	COMPAT_FREEBSD4		# Compatible with FreeBSD4
+options 	COMPAT_FREEBSD5		# Compatible with FreeBSD5
+options 	COMPAT_FREEBSD6		# Compatible with FreeBSD6
+options 	COMPAT_FREEBSD7		# Compatible with FreeBSD7
+options 	SCSI_DELAY=5000		# Delay (in ms) before probing SCSI
+options 	KTRACE			# ktrace(1) support
+options 	STACK			# stack(9) support
+options 	SYSVSHM			# SYSV-style shared memory
+options 	SYSVMSG			# SYSV-style message queues
+options 	SYSVSEM			# SYSV-style semaphores
+options 	_KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
+options 	PRINTF_BUFR_SIZE=128	# Prevent printf output being interspersed.
+options 	KBD_INSTALL_CDEV	# install a CDEV entry in /dev
+options 	HWPMC_HOOKS		# Necessary kernel hooks for hwpmc(4)
+options 	AUDIT			# Security event auditing
+options 	CAPABILITY_MODE		# Capsicum capability mode
+options 	CAPABILITIES		# Capsicum capabilities
+options 	PROCDESC		# Support for process descriptors
+options 	MAC			# TrustedBSD MAC Framework
+#options 	KDTRACE_FRAME		# Ensure frames are compiled in
+#options 	KDTRACE_HOOKS		# Kernel DTrace hooks
+#options 	DDB_CTF			# Kernel ELF linker loads CTF data
+options 	INCLUDE_CONFIG_FILE     # Include this file in kernel
+
+# Debugging support.  Always need this:
+options 	KDB			# Enable kernel debugger support.
+options 	KDB_TRACE		# Print a stack trace for a panic.
+options		DDB			# Support DDB.
+
+# Make an SMP-capable kernel by default
+options 	SMP			# Symmetric MultiProcessor Kernel
+
+# CPU frequency control
+device		cpufreq
+
+# Bus support.
+device		acpi
+device		pci
+
+# Floppy drives
+#device		fdc
+
+# ATA controllers
+device		ahci		# AHCI-compatible SATA controllers
+#device		ata		# Legacy ATA/SATA controllers
+#options 	ATA_STATIC_ID	# Static device numbering
+#device		mvs		# Marvell 88SX50XX/88SX60XX/88SX70XX/SoC SATA
+#device		siis		# SiliconImage SiI3124/SiI3132/SiI3531 SATA
+
+# SCSI Controllers
+#device		ahc		# AHA2940 and onboard AIC7xxx devices
+#options 	AHC_REG_PRETTY_PRINT	# Print register bitfields in debug
+#					# output.  Adds ~128k to driver.
+#device		ahd		# AHA39320/29320 and onboard AIC79xx devices
+#options 	AHD_REG_PRETTY_PRINT	# Print register bitfields in debug
+#					# output.  Adds ~215k to driver.
+#device		esp		# AMD Am53C974 (Tekram DC-390(T))
+#device		hptiop		# Highpoint RocketRaid 3xxx series
+#device		isp		# Qlogic family
+#device		ispfw		# Firmware for QLogic HBAs- normally a module
+#device		mpt		# LSI-Logic MPT-Fusion
+#device		mps		# LSI-Logic MPT-Fusion 2
+#device		ncr		# NCR/Symbios Logic
+#device		sym		# NCR/Symbios Logic (newer chipsets + those of `ncr')
+#device		trm		# Tekram DC395U/UW/F DC315U adapters
+
+#device		adv		# Advansys SCSI adapters
+#device		adw		# Advansys wide SCSI adapters
+#device		aic		# Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
+#device		bt		# Buslogic/Mylex MultiMaster SCSI adapters
+#device		isci		# Intel C600 SAS controller
+
+# ATA/SCSI peripherals
+device		scbus		# SCSI bus (required for ATA/SCSI)
+#device		ch		# SCSI media changers
+device		da		# Direct Access (disks)
+#device		sa		# Sequential Access (tape etc)
+#device		cd		# CD
+device		pass		# Passthrough device (direct ATA/SCSI access)
+device		ses		# Enclosure Services (SES and SAF-TE)
+#device		ctl		# CAM Target Layer
+
+# RAID controllers interfaced to the SCSI subsystem
+#device		amr		# AMI MegaRAID
+#device		arcmsr		# Areca SATA II RAID
+#XXX it is not 64-bit clean, -scottl
+#device		asr		# DPT SmartRAID V, VI and Adaptec SCSI RAID
+#device		ciss		# Compaq Smart RAID 5*
+#device		dpt		# DPT Smartcache III, IV - See NOTES for options
+#device		hptmv		# Highpoint RocketRAID 182x
+#device		hptnr		# Highpoint DC7280, R750
+#device		hptrr		# Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
+#device		hpt27xx		# Highpoint RocketRAID 27xx
+#device		iir		# Intel Integrated RAID
+#device		ips		# IBM (Adaptec) ServeRAID
+#device		mly		# Mylex AcceleRAID/eXtremeRAID
+#device		twa		# 3ware 9000 series PATA/SATA RAID
+#device		tws		# LSI 3ware 9750 SATA+SAS 6Gb/s RAID controller
+
+# RAID controllers
+#device		aac		# Adaptec FSA RAID
+#device		aacp		# SCSI passthrough for aac (requires CAM)
+#device		aacraid		# Adaptec by PMC RAID
+#device		ida		# Compaq Smart RAID
+#device		mfi		# LSI MegaRAID SAS
+#device		mlx		# Mylex DAC960 family
+#XXX pointer/int warnings
+#device		pst		# Promise Supertrak SX6000
+#device		twe		# 3ware ATA RAID
+
+# atkbdc0 controls both the keyboard and the PS/2 mouse
+device		atkbdc		# AT keyboard controller
+device		atkbd		# AT keyboard
+device		psm		# PS/2 mouse
+
+device		kbdmux		# keyboard multiplexer
+
+device		vga		# VGA video card driver
+options 	VESA		# Add support for VESA BIOS Extensions (VBE)
+
+#device		splash		# Splash screen and screen saver support
+
+# syscons is the default console driver, resembling an SCO console
+device		sc
+options 	SC_PIXEL_MODE	# add support for the raster text mode
+
+device		agp		# support several AGP chipsets
+
+# PCCARD (PCMCIA) support
+# PCMCIA and cardbus bridge support
+#device		cbb		# cardbus (yenta) bridge
+#device		pccard		# PC Card (16-bit) bus
+#device		cardbus		# CardBus (32-bit) bus
+
+# Serial (COM) ports
+device		uart		# Generic UART driver
+
+# Parallel port
+#device		ppc
+#device		ppbus		# Parallel port bus (required)
+#device		lpt		# Printer
+#device		ppi		# Parallel port interface device
+#device		vpo		# Requires scbus and da
+
+#device		puc		# Multi I/O cards and multi-channel UARTs
+
+# PCI Ethernet NICs.
+#device		bxe		# Broadcom NetXtreme II BCM5771X/BCM578XX 10GbE
+#device		de		# DEC/Intel DC21x4x (``Tulip'')
+device		em		# Intel PRO/1000 Gigabit Ethernet Family
+#device		igb		# Intel PRO/1000 PCIE Server Gigabit Family
+#device		ixgbe		# Intel PRO/10GbE PCIE Ethernet Family
+#device		le		# AMD Am7900 LANCE and Am79C9xx PCnet
+#device		ti		# Alteon Networks Tigon I/II gigabit Ethernet
+#device		txp		# 3Com 3cR990 (``Typhoon'')
+#device		vx		# 3Com 3c590, 3c595 (``Vortex'')
+
+# PCI Ethernet NICs that use the common MII bus controller code.
+# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
+device		miibus		# MII bus support
+#device		ae		# Attansic/Atheros L2 FastEthernet
+#device		age		# Attansic/Atheros L1 Gigabit Ethernet
+#device		alc		# Atheros AR8131/AR8132 Ethernet
+#device		ale		# Atheros AR8121/AR8113/AR8114 Ethernet
+#device		bce		# Broadcom BCM5706/BCM5708 Gigabit Ethernet
+#device		bfe		# Broadcom BCM440x 10/100 Ethernet
+#device		bge		# Broadcom BCM570xx Gigabit Ethernet
+#device		cas		# Sun Cassini/Cassini+ and NS DP83065 Saturn
+#device		dc		# DEC/Intel 21143 and various workalikes
+#device		et		# Agere ET1310 10/100/Gigabit Ethernet
+#device		fxp		# Intel EtherExpress PRO/100B (82557, 82558)
+#device		gem		# Sun GEM/Sun ERI/Apple GMAC
+#device		hme		# Sun HME (Happy Meal Ethernet)
+#device		jme		# JMicron JMC250 Gigabit/JMC260 Fast Ethernet
+#device		lge		# Level 1 LXT1001 gigabit Ethernet
+device		msk		# Marvell/SysKonnect Yukon II Gigabit Ethernet
+#device		nfe		# nVidia nForce MCP on-board Ethernet
+#device		nge		# NatSemi DP83820 gigabit Ethernet
+#device		nve		# nVidia nForce MCP on-board Ethernet Networking
+#device		pcn		# AMD Am79C97x PCI 10/100 (precedence over 'le')
+#device		re		# RealTek 8139C+/8169/8169S/8110S
+#device		rl		# RealTek 8129/8139
+#device		sf		# Adaptec AIC-6915 (``Starfire'')
+#device		sge		# Silicon Integrated Systems SiS190/191
+#device		sis		# Silicon Integrated Systems SiS 900/SiS 7016
+device		sk		# SysKonnect SK-984x & SK-982x gigabit Ethernet
+#device		ste		# Sundance ST201 (D-Link DFE-550TX)
+#device		stge		# Sundance/Tamarack TC9021 gigabit Ethernet
+#device		tl		# Texas Instruments ThunderLAN
+#device		tx		# SMC EtherPower II (83c170 ``EPIC'')
+#device		vge		# VIA VT612x gigabit Ethernet
+#device		vr		# VIA Rhine, Rhine II
+#device		wb		# Winbond W89C840F
+#device		xl		# 3Com 3c90x (``Boomerang'', ``Cyclone'')
+
+# ISA Ethernet NICs.  pccard NICs included.
+#device		cs		# Crystal Semiconductor CS89x0 NIC
+# 'device ed' requires 'device miibus'
+#device		ed		# NE[12]000, SMC Ultra, 3c503, DS8390 cards
+#device		ex		# Intel EtherExpress Pro/10 and Pro/10+
+#device		ep		# Etherlink III based cards
+#device		fe		# Fujitsu MB8696x based cards
+#device		sn		# SMC's 9000 series of Ethernet chips
+#device		xe		# Xircom pccard Ethernet
+
+# Wireless NIC cards
+device		wlan		# 802.11 support
+options 	IEEE80211_DEBUG	# enable debug msgs
+options 	IEEE80211_AMPDU_AGE # age frames in AMPDU reorder q's
+options 	IEEE80211_SUPPORT_MESH	# enable 802.11s draft support
+device		wlan_wep	# 802.11 WEP support
+device		wlan_ccmp	# 802.11 CCMP support
+device		wlan_tkip	# 802.11 TKIP support
+device		wlan_amrr	# AMRR transmit rate control algorithm
+#device		an		# Aironet 4500/4800 802.11 wireless NICs.
+#device		ath		# Atheros NICs
+#device		ath_pci		# Atheros pci/cardbus glue
+#device		ath_hal		# pci/cardbus chip support
+#options 	AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
+#options 	AH_AR5416_INTERRUPT_MITIGATION	# AR5416 interrupt mitigation
+#options 	ATH_ENABLE_11N	# Enable 802.11n support for AR5416 and later
+#device		ath_rate_sample	# SampleRate tx rate control for ath
+#device		bwi		# Broadcom BCM430x/BCM431x wireless NICs.
+#device		bwn		# Broadcom BCM43xx wireless NICs.
+#device		ipw		# Intel 2100 wireless NICs.
+#device		iwi		# Intel 2200BG/2225BG/2915ABG wireless NICs.
+device		iwn		# Intel 4965/1000/5000/6000 wireless NICs.
+#device		malo		# Marvell Libertas wireless NICs.
+#device		mwl		# Marvell 88W8363 802.11n wireless NICs.
+#device		ral		# Ralink Technology RT2500 wireless NICs.
+#device		wi		# WaveLAN/Intersil/Symbol 802.11 wireless NICs.
+#device		wpi		# Intel 3945ABG wireless NICs.
+
+# Pseudo devices.
+device		loop		# Network loopback
+device		random		# Entropy device
+#device		padlock_rng	# VIA Padlock RNG
+device		rdrand_rng	# Intel Bull Mountain RNG
+device		ether		# Ethernet support
+device		vlan		# 802.1Q VLAN support
+device		tun		# Packet tunnel.
+device		md		# Memory "disks"
+device		gif		# IPv6 and IPv4 tunneling
+device		faith		# IPv6-to-IPv4 relaying (translation)
+device		firmware	# firmware assist module
+
+# The `bpf' device enables the Berkeley Packet Filter.
+# Be aware of the administrative consequences of enabling this!
+# Note that 'bpf' is required for DHCP.
+device		bpf		# Berkeley packet filter
+
+# USB support
+options 	USB_DEBUG	# enable debug msgs
+device		uhci		# UHCI PCI->USB interface
+device		ohci		# OHCI PCI->USB interface
+device		ehci		# EHCI PCI->USB interface (USB 2.0)
+device		xhci		# XHCI PCI->USB interface (USB 3.0)
+device		usb		# USB Bus (required)
+device		ukbd		# Keyboard
+device		ums		# Mouse
+#device		umass		# Disks/Mass storage - Requires scbus and da
+
+# Sound support
+device		sound		# Generic sound driver (required)
+#device		snd_cmi		# CMedia CMI8338/CMI8738
+#device		snd_csa		# Crystal Semiconductor CS461x/428x
+#device		snd_emu10kx	# Creative SoundBlaster Live! and Audigy
+#device		snd_es137x	# Ensoniq AudioPCI ES137x
+device		snd_hda		# Intel High Definition Audio
+#device		snd_ich		# Intel, NVidia and other ICH AC'97 Audio
+#device		snd_via8233	# VIA VT8233x Audio
+
+# MMC/SD
+#device		mmc		# MMC/SD bus
+#device		mmcsd		# MMC/SD memory card
+#device		sdhci		# Generic PCI SD Host Controller
+
+# VirtIO support
+#device		virtio		# Generic VirtIO bus (required)
+#device		virtio_pci	# VirtIO PCI device
+#device		vtnet		# VirtIO Ethernet device
+#device		virtio_blk	# VirtIO Block device
+#device		virtio_scsi	# VirtIO SCSI device
+#device		virtio_balloon	# VirtIO Memory Balloon device
+
+# HyperV drivers
+#device		hyperv		# HyperV drivers 
+
+# Xen HVM Guest Optimizations
+# NOTE: XENHVM depends on xenpci.  They must be added or removed together.
+#options 	XENHVM		# Xen HVM kernel infrastructure
+#device		xenpci		# Xen HVM Hypervisor services driver
+
+# VMware support
+#device		vmx		# VMware VMXNET3 Ethernet
+
+# hw
+device		coretemp
+device		cpuctl
+
+# sc related
+options		SC_DISABLE_REBOOT
+
+# ukbd
+options		UKBD_DFLT_KEYMAP
+makeoptions	UKBD_DFLT_KEYMAP=us.pc-ctrl
+
+# ipfw
+options		IPFIREWALL
+options		IPFIREWALL_VERBOSE
+options		IPFIREWALL_VERBOSE_LIMIT=100
+options		IPSTEALTH
+
+# crypto
+device		crypto			# core crypto support
+device		cryptodev		# /dev/crypto for access to h/w
+device		aesni
+
+# sec
+options		MALLOC_DEBUG_MAXZONES=8	# Separate malloc(9) zones
+
+options 	DEADLKRES               # Enable the deadlock resolver
+options 	INVARIANTS              # Enable calls of extra sanity c
+options 	INVARIANT_SUPPORT       # Extra sanity checks of interna
+options 	WITNESS                 # Enable checks to detect deadlo
+options 	WITNESS_SKIPSPIN        # Don't run witness on spinlocks
+
+options 	ALT_BREAK_TO_DEBUGGER
+options 	BREAK_TO_DEBUGGER
+
+options		PAX_ASLR
+options		PAX_SEGVGUARD
+options		MAC_BSDEXTENDED
diff --git a/sys/amd64/include/vmparam.h b/sys/amd64/include/vmparam.h
index bda9722..5e83a8f 100644
--- a/sys/amd64/include/vmparam.h
+++ b/sys/amd64/include/vmparam.h
@@ -170,7 +170,7 @@
 #define	VM_MAXUSER_ADDRESS	UVADDR(NUPML4E, 0, 0, 0)
 
 #define	SHAREDPAGE		(VM_MAXUSER_ADDRESS - PAGE_SIZE)
-#define	USRSTACK		SHAREDPAGE
+#define	USRSTACK		(SHAREDPAGE - 4*PAGE_SIZE)
 
 #define	VM_MAX_ADDRESS		UPT_MAX_ADDRESS
 #define	VM_MIN_ADDRESS		(0)
diff --git a/sys/amd64/linux32/linux32_sysvec.c b/sys/amd64/linux32/linux32_sysvec.c
index 9b5c555..71c891d 100644
--- a/sys/amd64/linux32/linux32_sysvec.c
+++ b/sys/amd64/linux32/linux32_sysvec.c
@@ -33,6 +33,7 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 #include "opt_compat.h"
+#include "opt_pax.h"
 
 #ifndef COMPAT_FREEBSD32
 #error "Unable to compile Linux-emulator due to missing COMPAT_FREEBSD32 option!"
@@ -84,6 +85,10 @@ __FBSDID("$FreeBSD$");
 #include <compat/linux/linux_signal.h>
 #include <compat/linux/linux_util.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 MODULE_VERSION(linux, 1);
 
 MALLOC_DEFINE(M_LINUX, "linux", "Linux mode structures");
@@ -1037,6 +1042,11 @@ struct sysentvec elf_linux_sysvec = {
 	.sv_shared_page_base = LINUX32_SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= linux_schedtail,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf_sysvec, &elf_linux_sysvec);
 
diff --git a/sys/arm/arm/elf_machdep.c b/sys/arm/arm/elf_machdep.c
index 8ef9bd4..26e37e6 100644
--- a/sys/arm/arm/elf_machdep.c
+++ b/sys/arm/arm/elf_machdep.c
@@ -26,6 +26,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -46,6 +48,10 @@ __FBSDID("$FreeBSD$");
 #include <machine/elf.h>
 #include <machine/md_var.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 struct sysentvec elf32_freebsd_sysvec = {
 	.sv_size	= SYS_MAXSYSCALL,
 	.sv_table	= sysent,
@@ -79,6 +85,11 @@ struct sysentvec elf32_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 static Elf32_Brandinfo freebsd_brand_info = {
diff --git a/sys/arm/conf/LATT-ASLR b/sys/arm/conf/LATT-ASLR
new file mode 100644
index 0000000..cdc4efd
--- /dev/null
+++ b/sys/arm/conf/LATT-ASLR
@@ -0,0 +1,6 @@
+include RPI-B
+
+options PAX_ASLR
+options PAX_SYSCTLS
+#options PAX_SEGVGUARD
+options VIMAGE
diff --git a/sys/boot/i386/boot2/Makefile b/sys/boot/i386/boot2/Makefile
index fa8c29d..6047c31 100644
--- a/sys/boot/i386/boot2/Makefile
+++ b/sys/boot/i386/boot2/Makefile
@@ -22,6 +22,8 @@ BOOT2_UFS?=	UFS1_AND_UFS2
 #BOOT2_UFS?=	UFS2_ONLY
 #BOOT2_UFS?=	UFS1_ONLY
 
+NO_PIE=yes
+
 CFLAGS=	-Os \
 	-fomit-frame-pointer \
 	-mrtd \
diff --git a/sys/boot/i386/btx/btx/Makefile b/sys/boot/i386/btx/btx/Makefile
index 0f5a468..077a0c1 100644
--- a/sys/boot/i386/btx/btx/Makefile
+++ b/sys/boot/i386/btx/btx/Makefile
@@ -5,6 +5,8 @@ INTERNALPROG=
 MAN=
 SRCS=	btx.S
 
+NO_PIE=yes
+
 .if defined(BOOT_BTX_NOHANG)
 BOOT_BTX_FLAGS=0x1
 .else
diff --git a/sys/boot/i386/btx/btxldr/Makefile b/sys/boot/i386/btx/btxldr/Makefile
index 7e57ca3..e09f43e 100644
--- a/sys/boot/i386/btx/btxldr/Makefile
+++ b/sys/boot/i386/btx/btxldr/Makefile
@@ -5,6 +5,8 @@ INTERNALPROG=
 MAN=
 SRCS=	btxldr.S
 
+NO_PIE=yes
+
 CFLAGS+=-DLOADER_ADDRESS=${LOADER_ADDRESS}
 CFLAGS+=-I${.CURDIR}/../../common
 
diff --git a/sys/boot/i386/btx/lib/Makefile b/sys/boot/i386/btx/lib/Makefile
index c66f0fc..c34a462 100644
--- a/sys/boot/i386/btx/lib/Makefile
+++ b/sys/boot/i386/btx/lib/Makefile
@@ -7,4 +7,6 @@ SRCS=	btxcsu.S btxsys.s btxv86.s
 CFLAGS+=-I${.CURDIR}/../../common
 LDFLAGS=-Wl,-r
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/sys/boot/i386/loader/Makefile b/sys/boot/i386/loader/Makefile
index b331012..c7d1fa4 100644
--- a/sys/boot/i386/loader/Makefile
+++ b/sys/boot/i386/loader/Makefile
@@ -8,6 +8,8 @@ PROG=		${LOADER}.sym
 INTERNALPROG=
 NEWVERSWHAT?=	"bootstrap loader" x86
 
+NO_PIE=yes
+
 # architecture-specific loader code
 SRCS=		main.c conf.c vers.c
 
diff --git a/sys/boot/mips/beri/boot2/Makefile b/sys/boot/mips/beri/boot2/Makefile
index 325edbc..2516142 100644
--- a/sys/boot/mips/beri/boot2/Makefile
+++ b/sys/boot/mips/beri/boot2/Makefile
@@ -32,6 +32,8 @@
 BINDIR?=	/boot
 INSTALLFLAGS=	-b
 
+NO_PIE=yes
+
 LOADERS=	flashboot jtagboot
 FILES=		${LOADERS} ${LOADERS:S/$/.md5/}
 
diff --git a/sys/boot/mips/beri/loader/Makefile b/sys/boot/mips/beri/loader/Makefile
index 3da7f7f..f6fa8bb 100644
--- a/sys/boot/mips/beri/loader/Makefile
+++ b/sys/boot/mips/beri/loader/Makefile
@@ -36,6 +36,8 @@ PROG?=		loader
 NEWVERSWHAT=	"BERI loader" ${MACHINE_CPUARCH}
 INSTALLFLAGS=	-b
 
+NO_PIE=yes
+
 # Architecture-specific loader code
 SRCS=		start.S						\
 		main.c						\
diff --git a/sys/boot/pc98/boot2/Makefile b/sys/boot/pc98/boot2/Makefile
index 88076a8..72054eb 100644
--- a/sys/boot/pc98/boot2/Makefile
+++ b/sys/boot/pc98/boot2/Makefile
@@ -6,6 +6,8 @@
 CC:=		gcc
 COMPILER_TYPE:=	gcc
 
+NO_PIE=yes
+
 FILES=		boot boot1 boot2
 
 NM?=		nm
diff --git a/sys/boot/pc98/btx/btx/Makefile b/sys/boot/pc98/btx/btx/Makefile
index 905908f..ebdd0eb 100644
--- a/sys/boot/pc98/btx/btx/Makefile
+++ b/sys/boot/pc98/btx/btx/Makefile
@@ -5,6 +5,8 @@ INTERNALPROG=
 MAN=
 SRCS=	btx.S
 
+NO_PIE=yes
+
 .if defined(BOOT_BTX_NOHANG)
 BOOT_BTX_FLAGS=0x1
 .else
diff --git a/sys/boot/pc98/btx/btxldr/Makefile b/sys/boot/pc98/btx/btxldr/Makefile
index 7d34e9e..125d5c2 100644
--- a/sys/boot/pc98/btx/btxldr/Makefile
+++ b/sys/boot/pc98/btx/btxldr/Makefile
@@ -5,6 +5,8 @@ INTERNALPROG=
 MAN=
 SRCS=	btxldr.S
 
+NO_PIE=yes
+
 CFLAGS+=-DLOADER_ADDRESS=${LOADER_ADDRESS}
 CFLAGS+=-I${.CURDIR}/../../../i386/common
 
diff --git a/sys/boot/pc98/btx/lib/Makefile b/sys/boot/pc98/btx/lib/Makefile
index e5876bc..caf5f68 100644
--- a/sys/boot/pc98/btx/lib/Makefile
+++ b/sys/boot/pc98/btx/lib/Makefile
@@ -7,4 +7,6 @@ SRCS=	btxcsu.S btxsys.s btxv86.s
 CFLAGS+=-I${.CURDIR}/../../../i386/common
 LDFLAGS=-Wl,-r
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/sys/boot/pc98/loader/Makefile b/sys/boot/pc98/loader/Makefile
index 7ab13a1..540dee6 100644
--- a/sys/boot/pc98/loader/Makefile
+++ b/sys/boot/pc98/loader/Makefile
@@ -8,6 +8,8 @@ PROG=		${LOADER}.sym
 INTERNALPROG=
 NEWVERSWHAT=	"bootstrap loader" pc98
 
+NO_PIE=yes
+
 # architecture-specific loader code
 SRCS=		main.c conf.c vers.c
 .PATH:		${.CURDIR}/../../i386/loader
diff --git a/sys/boot/sparc64/boot1/Makefile b/sys/boot/sparc64/boot1/Makefile
index 5150c3b..06901d2 100644
--- a/sys/boot/sparc64/boot1/Makefile
+++ b/sys/boot/sparc64/boot1/Makefile
@@ -7,6 +7,8 @@ FILES?=	boot1
 SRCS=	_start.s boot1.c
 CLEANFILES=${FILES} boot1.aout
 
+NO_PIE=yes
+
 BOOTBLOCKBASE= 0x4000
 
 CFLAGS.clang+=-mcmodel=small
diff --git a/sys/boot/sparc64/loader/Makefile b/sys/boot/sparc64/loader/Makefile
index d7266ad..60bcafb 100644
--- a/sys/boot/sparc64/loader/Makefile
+++ b/sys/boot/sparc64/loader/Makefile
@@ -7,6 +7,8 @@ PROG?=		loader
 NEWVERSWHAT?=	"bootstrap loader" sparc64
 INSTALLFLAGS=	-b
 
+NO_PIE=yes
+
 # Architecture-specific loader code
 SRCS=		locore.S main.c metadata.c vers.c
 
diff --git a/sys/compat/freebsd32/freebsd32_misc.c b/sys/compat/freebsd32/freebsd32_misc.c
index 68e761b..96a81d9 100644
--- a/sys/compat/freebsd32/freebsd32_misc.c
+++ b/sys/compat/freebsd32/freebsd32_misc.c
@@ -30,6 +30,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_compat.h"
 #include "opt_inet.h"
 #include "opt_inet6.h"
+#include "opt_pax.h"
 
 #define __ELF_WORD_SIZE 32
 
@@ -113,6 +114,10 @@ __FBSDID("$FreeBSD$");
 
 FEATURE(compat_freebsd_32bit, "Compatible with 32-bit FreeBSD");
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 #ifndef __mips__
 CTASSERT(sizeof(struct timeval32) == 8);
 CTASSERT(sizeof(struct timespec32) == 8);
@@ -2886,6 +2891,10 @@ freebsd32_copyout_strings(struct image_params *imgp)
 		szsigcode = 0;
 	destp =	(uintptr_t)arginfo;
 
+#ifdef PAX_ASLR
+	pax_aslr_stack(curthread, &destp);
+#endif
+
 	/*
 	 * install sigcode
 	 */
diff --git a/sys/compat/ia32/ia32_sysvec.c b/sys/compat/ia32/ia32_sysvec.c
index a8e52e8..ade8da5 100644
--- a/sys/compat/ia32/ia32_sysvec.c
+++ b/sys/compat/ia32/ia32_sysvec.c
@@ -29,6 +29,7 @@
 __FBSDID("$FreeBSD$");
 
 #include "opt_compat.h"
+#include "opt_pax.h"
 
 #define __ELF_WORD_SIZE 32
 
@@ -74,6 +75,10 @@ __FBSDID("$FreeBSD$");
 #include <machine/pcb.h>
 #include <machine/cpufunc.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 CTASSERT(sizeof(struct ia32_mcontext) == 640);
 CTASSERT(sizeof(struct ia32_ucontext) == 704);
 CTASSERT(sizeof(struct ia32_sigframe) == 800);
@@ -139,6 +144,11 @@ struct sysentvec ia32_freebsd_sysvec = {
 	.sv_shared_page_base = FREEBSD32_SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf_ia32_sysvec, &ia32_freebsd_sysvec);
 
diff --git a/sys/conf/NOTES b/sys/conf/NOTES
index f88411e..57732d6 100644
--- a/sys/conf/NOTES
+++ b/sys/conf/NOTES
@@ -2971,3 +2971,6 @@ options 	RANDOM_RWFILE	# Read and write entropy cache
 
 # Module to enable execution of application via emulators like QEMU
 options         IMAGACT_BINMISC
+
+# Address Space Layout Randomization (ASLR)
+options		PAX_ASLR
diff --git a/sys/conf/files b/sys/conf/files
index abe4b2f..6510b82 100644
--- a/sys/conf/files
+++ b/sys/conf/files
@@ -2905,6 +2905,10 @@ kern/kern_mtxpool.c		standard
 kern/kern_mutex.c		standard
 kern/kern_ntptime.c		standard
 kern/kern_osd.c			standard
+kern/kern_pax.c			optional pax_aslr | pax_segvguard
+kern/kern_pax_aslr.c		optional pax_aslr
+kern/kern_pax_log.c		optional pax_aslr | pax_segvguard
+kern/kern_pax_segvguard.c	optional pax_segvguard
 kern/kern_physio.c		standard
 kern/kern_pmc.c			standard
 kern/kern_poll.c		optional device_polling
diff --git a/sys/conf/options b/sys/conf/options
index f181dde..49d64f4 100644
--- a/sys/conf/options
+++ b/sys/conf/options
@@ -914,6 +914,13 @@ RACCT		opt_global.h
 # Resource Limits
 RCTL		opt_global.h
 
+# PaX - hardening options
+PAX_ASLR	opt_pax.h
+PAX_ASLR_MAX_SEC	opt_pax.h
+PAX_MPROTECT	opt_pax.h
+PAX_SEGVGUARD	opt_pax.h
+PAX_SYSCTLS	opt_pax.h
+
 # Random number generator(s)
 RANDOM_YARROW	opt_random.h
 RANDOM_FORTUNA	opt_random.h
diff --git a/sys/i386/conf/LATT-ASLR b/sys/i386/conf/LATT-ASLR
new file mode 100644
index 0000000..4e9e3a0
--- /dev/null
+++ b/sys/i386/conf/LATT-ASLR
@@ -0,0 +1,7 @@
+include GENERIC
+
+options PAX_ASLR
+options PAX_SEGVGUARD
+
+options VIMAGE
+options GEOM_PART_VTOC8
diff --git a/sys/i386/i386/elf_machdep.c b/sys/i386/i386/elf_machdep.c
index 034b4c4..9571252 100644
--- a/sys/i386/i386/elf_machdep.c
+++ b/sys/i386/i386/elf_machdep.c
@@ -26,6 +26,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -46,6 +48,10 @@ __FBSDID("$FreeBSD$");
 #include <machine/elf.h>
 #include <machine/md_var.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 struct sysentvec elf32_freebsd_sysvec = {
 	.sv_size	= SYS_MAXSYSCALL,
 	.sv_table	= sysent,
@@ -81,6 +87,11 @@ struct sysentvec elf32_freebsd_sysvec = {
 	.sv_shared_page_base = SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf32_sysvec, &elf32_freebsd_sysvec);
 
diff --git a/sys/i386/ibcs2/ibcs2_sysvec.c b/sys/i386/ibcs2/ibcs2_sysvec.c
index 5d007c7..1bb9d89 100644
--- a/sys/i386/ibcs2/ibcs2_sysvec.c
+++ b/sys/i386/ibcs2/ibcs2_sysvec.c
@@ -31,6 +31,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -50,6 +52,10 @@ __FBSDID("$FreeBSD$");
 #include <i386/ibcs2/ibcs2_syscall.h>
 #include <i386/ibcs2/ibcs2_signal.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 MODULE_VERSION(ibcs2, 1);
 
 extern int bsd_to_ibcs2_errno[];
@@ -89,6 +95,11 @@ struct sysentvec ibcs2_svr3_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = NULL,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init, /* XXXOP */
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 static int
diff --git a/sys/i386/linux/linux_sysvec.c b/sys/i386/linux/linux_sysvec.c
index 60df6a2..affb195 100644
--- a/sys/i386/linux/linux_sysvec.c
+++ b/sys/i386/linux/linux_sysvec.c
@@ -29,6 +29,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/exec.h>
@@ -72,6 +74,10 @@ __FBSDID("$FreeBSD$");
 #include <compat/linux/linux_signal.h>
 #include <compat/linux/linux_util.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 MODULE_VERSION(linux, 1);
 
 MALLOC_DEFINE(M_LINUX, "linux", "Linux mode structures");
@@ -974,6 +980,11 @@ struct sysentvec linux_sysvec = {
 	.sv_shared_page_base = LINUX_SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= linux_schedtail,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init, /* XXXOP */
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(aout_sysvec, &linux_sysvec);
 
@@ -1012,6 +1023,11 @@ struct sysentvec elf_linux_sysvec = {
 	.sv_shared_page_base = LINUX_SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= linux_schedtail,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf_sysvec, &elf_linux_sysvec);
 
diff --git a/sys/ia64/ia64/elf_machdep.c b/sys/ia64/ia64/elf_machdep.c
index 05cb641..e3d19c1 100644
--- a/sys/ia64/ia64/elf_machdep.c
+++ b/sys/ia64/ia64/elf_machdep.c
@@ -25,6 +25,8 @@
  * $FreeBSD$
  */
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -49,6 +51,10 @@
 #include <machine/md_var.h>
 #include <machine/unwind.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 Elf_Addr link_elf_get_gp(linker_file_t);
 
 extern Elf_Addr fptr_storage[];
@@ -86,6 +92,12 @@ struct sysentvec elf64_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
+
 };
 
 static Elf64_Brandinfo freebsd_brand_info = {
diff --git a/sys/kern/imgact_aout.c b/sys/kern/imgact_aout.c
index 3ae78de..aac03f1 100644
--- a/sys/kern/imgact_aout.c
+++ b/sys/kern/imgact_aout.c
@@ -27,6 +27,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/exec.h>
 #include <sys/imgact.h>
@@ -62,6 +64,10 @@ __FBSDID("$FreeBSD$");
 #include <compat/ia32/ia32_signal.h>
 #endif
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 static int	exec_aout_imgact(struct image_params *imgp);
 static int	aout_fixup(register_t **stack_base, struct image_params *imgp);
 
@@ -99,6 +105,11 @@ struct sysentvec aout_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init, /* XXXOP */
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 #elif defined(__amd64__)
@@ -143,6 +154,11 @@ struct sysentvec aout_sysvec = {
 	.sv_set_syscall_retval = ia32_set_syscall_retval,
 	.sv_fetch_syscall_args = ia32_fetch_syscall_args,
 	.sv_syscallnames = freebsd32_syscallnames,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32, /* XXXOP */
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 #else
 #error "Port me"
diff --git a/sys/kern/imgact_elf.c b/sys/kern/imgact_elf.c
index a62efb8..c31aab2 100644
--- a/sys/kern/imgact_elf.c
+++ b/sys/kern/imgact_elf.c
@@ -34,6 +34,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_capsicum.h"
 #include "opt_compat.h"
 #include "opt_core.h"
+#include "opt_pax.h"
 
 #include <sys/param.h>
 #include <sys/capsicum.h>
@@ -48,6 +49,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/mman.h>
 #include <sys/namei.h>
 #include <sys/pioctl.h>
+#include <sys/jail.h>
 #include <sys/proc.h>
 #include <sys/procfs.h>
 #include <sys/racct.h>
@@ -81,6 +83,10 @@ __FBSDID("$FreeBSD$");
 #include <machine/elf.h>
 #include <machine/md_var.h>
 
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+#include <sys/pax.h>
+#endif
+
 #define ELF_NOTE_ROUNDSIZE	4
 #define OLD_EI_BRAND	8
 
@@ -684,16 +690,16 @@ __elfN(load_file)(struct proc *p, const char *file, u_long *addr,
 	hdr = (const Elf_Ehdr *)imgp->image_header;
 	if ((error = __elfN(check_header)(hdr)) != 0)
 		goto fail;
-	if (hdr->e_type == ET_DYN)
+	if (hdr->e_type == ET_DYN) {
 		rbase = *addr;
-	else if (hdr->e_type == ET_EXEC)
+	} else if (hdr->e_type == ET_EXEC) {
 		rbase = 0;
-	else {
+	} else {
 		error = ENOEXEC;
 		goto fail;
 	}
 
-	/* Only support headers that fit within first page for now      */
+	/* Only support headers that fit within first page for now */
 	if ((hdr->e_phoff > PAGE_SIZE) ||
 	    (u_int)hdr->e_phentsize * hdr->e_phnum > PAGE_SIZE - hdr->e_phoff) {
 		error = ENOEXEC;
@@ -818,16 +824,7 @@ __CONCAT(exec_, __elfN(imgact))(struct image_params *imgp)
 	if (hdr->e_type == ET_DYN) {
 		if ((brand_info->flags & BI_CAN_EXEC_DYN) == 0)
 			return (ENOEXEC);
-		/*
-		 * Honour the base load address from the dso if it is
-		 * non-zero for some reason.
-		 */
-		if (baddr == 0)
-			et_dyn_addr = ET_DYN_LOAD_ADDR;
-		else
-			et_dyn_addr = 0;
-	} else
-		et_dyn_addr = 0;
+	}
 	sv = brand_info->sysvec;
 	if (interp != NULL && brand_info->interp_newpath != NULL)
 		newinterp = brand_info->interp_newpath;
@@ -848,6 +845,27 @@ __CONCAT(exec_, __elfN(imgact))(struct image_params *imgp)
 	error = exec_new_vmspace(imgp, sv);
 	imgp->proc->p_sysent = sv;
 
+#if defined(PAX_MPROTECT) || defined(PAX_SEGVGUARD) || defined(PAX_ASLR)
+	pax_elf(imgp, 0);
+#endif
+
+	if (hdr->e_type == ET_DYN) {
+		/*
+		 * Honour the base load address from the dso if it is
+		 * non-zero for some reason.
+		 */
+		if (baddr == 0) {
+			et_dyn_addr = ET_DYN_LOAD_ADDR;
+#ifdef PAX_ASLR
+			if (pax_aslr_active(NULL, imgp->proc)) {
+				et_dyn_addr += imgp->proc->p_vmspace->vm_aslr_delta_exec;
+			}
+#endif
+		} else
+			et_dyn_addr = 0;
+	} else
+		et_dyn_addr = 0;
+
 	vn_lock(imgp->vp, LK_EXCLUSIVE | LK_RETRY);
 	if (error)
 		return (error);
diff --git a/sys/kern/init_main.c b/sys/kern/init_main.c
index 141d438..9301b57 100644
--- a/sys/kern/init_main.c
+++ b/sys/kern/init_main.c
@@ -410,6 +410,7 @@ struct sysentvec null_sysvec = {
 	.sv_fetch_syscall_args = null_fetch_syscall_args,
 	.sv_syscallnames = NULL,
 	.sv_schedtail	= NULL,
+	.sv_pax_aslr_init = NULL,
 };
 
 /*
diff --git a/sys/kern/kern_exec.c b/sys/kern/kern_exec.c
index 04c1c9a..e1d03d3 100644
--- a/sys/kern/kern_exec.c
+++ b/sys/kern/kern_exec.c
@@ -30,6 +30,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_capsicum.h"
 #include "opt_hwpmc_hooks.h"
 #include "opt_ktrace.h"
+#include "opt_pax.h"
 #include "opt_vm.h"
 
 #include <sys/param.h>
@@ -94,6 +95,10 @@ __FBSDID("$FreeBSD$");
 dtrace_execexit_func_t	dtrace_fasttrap_exec;
 #endif
 
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+#include <sys/pax.h>
+#endif
+
 SDT_PROVIDER_DECLARE(proc);
 SDT_PROBE_DEFINE1(proc, kernel, , exec, "char *");
 SDT_PROBE_DEFINE1(proc, kernel, , exec__failure, "int");
@@ -404,6 +409,7 @@ do_execve(td, args, mac_p)
 	imgp->pagesizes = 0;
 	imgp->pagesizeslen = 0;
 	imgp->stack_prot = 0;
+	imgp->pax_flags = 0;
 
 #ifdef MAC
 	error = mac_execve_enter(imgp, mac_p);
@@ -509,6 +515,11 @@ interpret:
 		error = (*execsw[i]->ex_imgact)(imgp);
 	}
 
+#ifdef PAX_SEGVGUARD
+	if (!error)
+		error = pax_segvguard(curthread, imgp->vp, args->fname, PAX_SEGVGUARD_NOTCRASHED);
+#endif
+
 	if (error) {
 		if (error == -1) {
 			if (textset == 0)
@@ -1064,6 +1075,10 @@ exec_new_vmspace(imgp, sv)
 		map = &vmspace->vm_map;
 	}
 
+#ifdef PAX_ASLR
+	pax_aslr_init(curthread, imgp);
+#endif
+
 	/* Map a shared page */
 	obj = sv->sv_shared_page_obj;
 	if (obj != NULL) {
@@ -1107,6 +1122,9 @@ exec_new_vmspace(imgp, sv)
 	 */
 	vmspace->vm_ssize = sgrowsiz >> PAGE_SHIFT;
 	vmspace->vm_maxsaddr = (char *)sv->sv_usrstack - ssiz;
+#ifdef PAX_ASLR
+	vmspace->vm_maxsaddr -= vmspace->vm_aslr_delta_stack;
+#endif
 
 	return (0);
 }
@@ -1266,6 +1284,9 @@ exec_copyout_strings(imgp)
 			szsigcode = *(p->p_sysent->sv_szsigcode);
 	}
 	destp =	(uintptr_t)arginfo;
+#ifdef PAX_ASLR
+	pax_aslr_stack(curthread, &destp);
+#endif
 
 	/*
 	 * install sigcode
diff --git a/sys/kern/kern_fork.c b/sys/kern/kern_fork.c
index b3d9c24..7e76de9 100644
--- a/sys/kern/kern_fork.c
+++ b/sys/kern/kern_fork.c
@@ -39,6 +39,7 @@ __FBSDID("$FreeBSD$");
 
 #include "opt_ktrace.h"
 #include "opt_kstack_pages.h"
+#include "opt_pax.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -53,6 +54,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/lock.h>
 #include <sys/malloc.h>
 #include <sys/mutex.h>
+#include <sys/pax.h>
 #include <sys/priv.h>
 #include <sys/proc.h>
 #include <sys/procdesc.h>
@@ -513,6 +515,11 @@ do_fork(struct thread *td, int flags, struct proc *p2, struct thread *td2,
 	}
 
 	/*
+	 * XXXOP: this is the right place?
+	 */
+	p2->p_pax = p1->p_pax;
+
+	/*
 	 * p_limit is copy-on-write.  Bump its refcount.
 	 */
 	lim_fork(p1, p2);
@@ -753,6 +760,15 @@ fork1(struct thread *td, int flags, int pages, struct proc **procp,
 	static struct timeval lastfail;
 	struct file *fp_procdesc = NULL;
 
+#ifdef PAX_SEGVGUARD
+	if (td->td_proc->p_pid != 0) {
+		error = pax_segvguard(curthread, curthread->td_proc->p_textvp, 
+				td->td_proc->p_comm, PAX_SEGVGUARD_NOTCRASHED);
+		if (error)
+			return (error);
+	}
+#endif
+
 	/* Check for the undefined or unimplemented flags. */
 	if ((flags & ~(RFFLAGS | RFTSIGFLAGS(RFTSIGMASK))) != 0)
 		return (EINVAL);
diff --git a/sys/kern/kern_jail.c b/sys/kern/kern_jail.c
index 47cd568..ea45ae1 100644
--- a/sys/kern/kern_jail.c
+++ b/sys/kern/kern_jail.c
@@ -33,6 +33,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_ddb.h"
 #include "opt_inet.h"
 #include "opt_inet6.h"
+#include "opt_pax.h"
 
 #include <sys/param.h>
 #include <sys/types.h>
@@ -74,6 +75,10 @@ __FBSDID("$FreeBSD$");
 #endif /* INET6 */
 #endif /* DDB */
 
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+#include <sys/pax.h>
+#endif
+
 #include <security/mac/mac_framework.h>
 
 #define	DEFAULT_HOSTUUID	"00000000-0000-0000-0000-000000000000"
@@ -114,8 +119,46 @@ struct prison prison0 = {
 	.pr_flags	= PR_HOST|_PR_IP_SADDRSEL,
 #endif
 	.pr_allow	= PR_ALLOW_ALL,
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+	.pr_pax_set		= 0,
+	.pr_pax_aslr_status	= PAX_ASLR_OPTIN,
+	.pr_pax_aslr_debug	= 0,
+	.pr_pax_aslr_mmap_len	= PAX_ASLR_DELTA_MMAP_MIN_LEN,
+	.pr_pax_aslr_stack_len	= PAX_ASLR_DELTA_STACK_MIN_LEN,
+	.pr_pax_aslr_exec_len	= PAX_ASLR_DELTA_EXEC_MIN_LEN,
+	.pr_pax_aslr_compat_status	= PAX_ASLR_OPTIN,
+	.pr_pax_aslr_compat_mmap_len	= PAX_ASLR_COMPAT_DELTA_MMAP_MIN_LEN,
+	.pr_pax_aslr_compat_stack_len	= PAX_ASLR_COMPAT_DELTA_STACK_MIN_LEN,
+	.pr_pax_aslr_compat_exec_len	= PAX_ASLR_COMPAT_DELTA_EXEC_MIN_LEN,
+	.pr_pax_segvguard_status	= PAX_SEGVGUARD_OPTIN,
+	.pr_pax_segvguard_debug		= 0,
+	.pr_pax_segvguard_expiry	= PAX_SEGVGUARD_EXPIRY,
+	.pr_pax_segvguard_suspension	= PAX_SEGVGUARD_SUSPENSION,
+	.pr_pax_segvguard_maxcrashes	= PAX_SEGVGUARD_MAXCRASHES,
+	.pr_pax_log_log			= PAX_LOG_LOG,
+	.pr_pax_log_ulog		= PAX_LOG_ULOG,
+#else
+	.pr_pax_set		= 0,
+	.pr_pax_aslr_status	= 0,
+	.pr_pax_aslr_debug	= 0,
+	.pr_pax_aslr_mmap_len	= 0,
+	.pr_pax_aslr_stack_len	= 0,
+	.pr_pax_aslr_exec_len	= 0,
+	.pr_pax_aslr_compat_status	= 0,
+	.pr_pax_aslr_compat_mmap_len	= 0,
+	.pr_pax_aslr_compat_stack_len	= 0,
+	.pr_pax_aslr_compat_exec_len	= 0,
+	.pr_pax_segvguard_status	= 0,
+	.pr_pax_segvguard_debug		= 0,
+	.pr_pax_segvguard_expiry	= 0,
+	.pr_pax_segvguard_suspension	= 0,
+	.pr_pax_segvguard_maxcrashes	= 0,
+	.pr_pax_log_log			= 0,
+	.pr_pax_log_ulog		= 0,
+#endif
 };
 MTX_SYSINIT(prison0, &prison0.pr_mtx, "jail mutex", MTX_DEF);
+SYSINIT(pax, SI_SUB_PAX, SI_ORDER_MIDDLE, pax_init_prison, (void *) &prison0);
 
 /* allprison, allprison_racct and lastprid are protected by allprison_lock. */
 struct	sx allprison_lock;
@@ -1307,6 +1350,10 @@ kern_jail_set(struct thread *td, struct uio *optuio, int flags)
 			goto done_releroot;
 		}
 
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+		pax_init_prison(pr);
+#endif
+
 		mtx_lock(&pr->pr_mtx);
 		/*
 		 * New prisons do not yet have a reference, because we do not
diff --git a/sys/kern/kern_pax.c b/sys/kern/kern_pax.c
new file mode 100644
index 0000000..cd741b6
--- /dev/null
+++ b/sys/kern/kern_pax.c
@@ -0,0 +1,253 @@
+/*-
+ * Copyright (c) 2006 Elad Efrat <elad@NetBSD.org>
+ * Copyright (c) 2013-2014, by Oliver Pinter <oliver.pntr at gmail.com>
+ * Copyright (c) 2014, by Shawn Webb <lattera at gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_compat.h"
+#include "opt_pax.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/imgact.h>
+#include <sys/imgact_elf.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/sysent.h>
+#include <sys/stat.h>
+#include <sys/proc.h>
+#include <sys/elf_common.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <sys/vnode.h>
+#include <sys/queue.h>
+#include <sys/libkern.h>
+#include <sys/jail.h>
+
+#include <sys/mman.h>
+#include <sys/libkern.h>
+#include <sys/exec.h>
+#include <sys/kthread.h>
+
+#include <sys/syslimits.h>
+#include <sys/param.h>
+
+#include <vm/pmap.h>
+#include <vm/vm_map.h>
+#include <vm/vm_extern.h>
+
+#include <machine/elf.h>
+
+#include <sys/pax.h>
+
+#include <security/mac_bsdextended/mac_bsdextended.h>
+
+SYSCTL_NODE(_security, OID_AUTO, pax, CTLFLAG_RD, 0,
+    "PaX (exploit mitigation) features.");
+
+struct prison *
+pax_get_prison(struct thread *td, struct proc *proc)
+{
+
+	if (td != NULL) {
+		if ((td->td_proc != NULL) && (td->td_proc->p_ucred != NULL)) {
+			return (td->td_proc->p_ucred->cr_prison);
+		}
+
+		return (NULL);
+	}
+	if ((proc == NULL) || (proc->p_ucred == NULL))
+		return (NULL);
+
+	return (proc->p_ucred->cr_prison);
+}
+
+void
+pax_elf(struct image_params *imgp, uint32_t mode)
+{
+	u_int flags = 0;
+
+	if ((mode & MBI_ALLPAX) == MBI_ALLPAX) {
+		goto end;
+	}
+
+	if (mode & MBI_FORCE_ASLR_ENABLED) {
+		flags |= PAX_NOTE_ASLR;
+	} else if (mode & MBI_FORCE_ASLR_DISABLED) {
+		flags |= PAX_NOTE_NOASLR;
+	}
+
+	if (mode & MBI_FORCE_SEGVGUARD_ENABLED) {
+		flags |= PAX_NOTE_GUARD;
+	} else if (mode & MBI_FORCE_SEGVGUARD_DISABLED) {
+		flags |= PAX_NOTE_NOGUARD;
+	}
+
+end:
+	if (imgp != NULL) {
+		imgp->pax_flags = flags;
+		if (imgp->proc != NULL) {
+			PROC_LOCK(imgp->proc);
+			imgp->proc->p_pax = flags;
+			PROC_UNLOCK(imgp->proc);
+		}
+	}
+}
+
+
+/*
+ * print out PaX settings on boot time, and validate some of them
+ */
+void
+pax_init(void)
+{
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+	const char *status_str[] = {
+		[0] = "disabled",
+		[1] = "opt-in",
+		[2] = "opt-out",
+		[3] = "force enabled",
+		[4] = "UNKNOWN -> changed to \"force enabled\""
+	};
+#endif
+
+#ifdef PAX_ASLR
+	switch (pax_aslr_status) {
+	case	0:
+	case	1:
+	case	2:
+	case	3:
+		break;
+	default:
+		printf("[PAX ASLR] WARNING, not valid PAX settings in loader.conf!"
+		    "(pax_aslr_status = %d)\n", pax_aslr_status);
+		pax_aslr_status = 3;
+		break;
+	}
+	printf("[PAX ASLR] status: %s\n", status_str[pax_aslr_status]);
+	printf("[PAX ASLR] mmap: %d bit\n", pax_aslr_mmap_len);
+	printf("[PAX ASLR] exec base: %d bit\n", pax_aslr_exec_len);
+	printf("[PAX ASLR] stack: %d bit\n", pax_aslr_stack_len);
+
+#ifdef COMPAT_FREEBSD32
+	switch (pax_aslr_compat_status) {
+	case	0:
+	case	1:
+	case	2:
+	case	3:
+		break;
+	default:
+		printf("[PAX ASLR (compat)] WARNING, not valid PAX settings in loader.conf! "
+		    "(pax_aslr_compat_status = %d)\n", pax_aslr_compat_status);
+		pax_aslr_compat_status = 3;
+		break;
+	}
+	printf("[PAX ASLR (compat)] status: %s\n", status_str[pax_aslr_compat_status]);
+	printf("[PAX ASLR (compat)] mmap: %d bit\n", pax_aslr_compat_mmap_len);
+	printf("[PAX ASLR (compat)] exec base: %d bit\n", pax_aslr_compat_exec_len);
+	printf("[PAX ASLR (compat)] stack: %d bit\n", pax_aslr_compat_stack_len);
+#endif
+#endif
+
+#ifdef PAX_SEGVGUARD
+	switch (pax_segvguard_status) {
+	case	0:
+	case	1:
+	case	2:
+	case	3:
+		break;
+	default:
+		printf("[PAX SEGVGUARD] WARNING, not valid PAX settings in loader.conf! "
+		    "(pax_segvguard_status = %d)\n", pax_segvguard_status);
+		pax_segvguard_status = 3;
+		break;
+	}
+	printf("[PAX SEGVGUARD] status: %s\n", status_str[pax_segvguard_status]);
+	printf("[PAX SEGVGUARD] maxcrashes: %d\n", pax_segvguard_maxcrashes);
+	printf("[PAX SEGVGUARD] expriry: %d sec\n", pax_segvguard_expiry);
+	printf("[PAX SEGVGUARD] suspension: %d sec\n", pax_segvguard_suspension);
+#endif
+
+	printf("[PAX LOG] logging to system: %d\n", pax_log_log);
+	printf("[PAX LOG] logging to user: %d\n", pax_log_ulog);
+}
+SYSINIT(pax, SI_SUB_PAX, SI_ORDER_FIRST, pax_init, NULL);
+
+void
+pax_init_prison(struct prison *pr)
+{
+
+	if (pr == NULL) {
+		return;
+	}
+
+	if (pr->pr_pax_set) {
+		return;
+	}
+
+	mtx_lock(&(pr->pr_mtx));
+
+	if (pax_aslr_debug) {
+		uprintf("[PaX ASLR/SEGVGUARD] %s: Setting prison %s ASLR variables\n",
+		    __func__, pr->pr_name);
+	}
+
+#ifdef PAX_ASLR
+	pr->pr_pax_aslr_status = pax_aslr_status;
+	pr->pr_pax_aslr_debug = pax_aslr_debug;
+	pr->pr_pax_aslr_mmap_len = pax_aslr_mmap_len;
+	pr->pr_pax_aslr_stack_len = pax_aslr_stack_len;
+	pr->pr_pax_aslr_exec_len = pax_aslr_exec_len;
+
+#ifdef COMPAT_FREEBSD32
+	pr->pr_pax_aslr_compat_status = pax_aslr_compat_status;
+	pr->pr_pax_aslr_compat_mmap_len = pax_aslr_compat_mmap_len;
+	pr->pr_pax_aslr_compat_stack_len = pax_aslr_compat_stack_len;
+	pr->pr_pax_aslr_compat_exec_len = pax_aslr_compat_exec_len;
+#endif
+#endif
+
+#ifdef PAX_SEGVGUARD
+	pr->pr_pax_segvguard_status = pax_segvguard_status;
+	pr->pr_pax_segvguard_debug = pax_segvguard_debug;
+	pr->pr_pax_segvguard_expiry = pax_segvguard_expiry;
+	pr->pr_pax_segvguard_suspension = pax_segvguard_suspension;
+	pr->pr_pax_segvguard_maxcrashes = pax_segvguard_maxcrashes;
+#endif
+
+	pr->pr_pax_log_log = pax_log_log;
+	pr->pr_pax_log_ulog = pax_log_ulog;
+
+	pr->pr_pax_set = 1;
+
+	mtx_unlock(&(pr->pr_mtx));
+}
diff --git a/sys/kern/kern_pax_aslr.c b/sys/kern/kern_pax_aslr.c
new file mode 100644
index 0000000..c3664e1
--- /dev/null
+++ b/sys/kern/kern_pax_aslr.c
@@ -0,0 +1,674 @@
+/*-
+ * Copyright (c) 2006 Elad Efrat <elad@NetBSD.org>
+ * Copyright (c) 2013-2014, by Oliver Pinter <oliver.pntr at gmail.com>
+ * Copyright (c) 2014, by Shawn Webb <lattera at gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_compat.h"
+#include "opt_pax.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/imgact.h>
+#include <sys/imgact_elf.h>
+#include <sys/sysent.h>
+#include <sys/stat.h>
+#include <sys/proc.h>
+#include <sys/elf_common.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <sys/vnode.h>
+#include <sys/queue.h>
+#include <sys/libkern.h>
+#include <sys/jail.h>
+
+#include <sys/mman.h>
+#include <sys/libkern.h>
+#include <sys/exec.h>
+#include <sys/kthread.h>
+
+#include <vm/pmap.h>
+#include <vm/vm_map.h>
+#include <vm/vm_extern.h>
+
+#include <machine/elf.h>
+
+#include <sys/pax.h>
+
+int pax_aslr_status = PAX_ASLR_OPTOUT;
+int pax_aslr_debug = 0;
+
+#ifdef PAX_ASLR_MAX_SEC
+int pax_aslr_mmap_len = PAX_ASLR_DELTA_MMAP_MAX_LEN;
+int pax_aslr_stack_len = PAX_ASLR_DELTA_STACK_MAX_LEN;
+int pax_aslr_exec_len = PAX_ASLR_DELTA_EXEC_MAX_LEN;
+#else
+int pax_aslr_mmap_len = PAX_ASLR_DELTA_MMAP_DEF_LEN;
+int pax_aslr_stack_len = PAX_ASLR_DELTA_STACK_DEF_LEN;
+int pax_aslr_exec_len = PAX_ASLR_DELTA_EXEC_DEF_LEN;
+#endif /* PAX_ASLR_MAX_SEC */
+
+#ifdef COMPAT_FREEBSD32
+int pax_aslr_compat_status = PAX_ASLR_OPTOUT;
+#ifdef PAX_ASLR_MAX_SEC
+int pax_aslr_compat_mmap_len = PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN;
+int pax_aslr_compat_stack_len = PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN;
+int pax_aslr_compat_exec_len = PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN;
+#else
+int pax_aslr_compat_mmap_len = PAX_ASLR_COMPAT_DELTA_MMAP_MIN_LEN;
+int pax_aslr_compat_stack_len = PAX_ASLR_COMPAT_DELTA_STACK_MIN_LEN;
+int pax_aslr_compat_exec_len = PAX_ASLR_COMPAT_DELTA_EXEC_MIN_LEN;
+#endif /* PAX_ASLR_MAX_SEC */
+#endif /* COMPAT_FREEBSD32 */
+
+TUNABLE_INT("security.pax.aslr.status", &pax_aslr_status);
+TUNABLE_INT("security.pax.aslr.mmap_len", &pax_aslr_mmap_len);
+TUNABLE_INT("security.pax.aslr.debug", &pax_aslr_debug);
+TUNABLE_INT("security.pax.aslr.stack_len", &pax_aslr_stack_len);
+TUNABLE_INT("security.pax.aslr.exec_len", &pax_aslr_exec_len);
+#ifdef COMPAT_FREEBSD32
+TUNABLE_INT("security.pax.aslr.compat.status", &pax_aslr_compat_status);
+TUNABLE_INT("security.pax.aslr.compat.mmap", &pax_aslr_compat_mmap_len);
+TUNABLE_INT("security.pax.aslr.compat.stack", &pax_aslr_compat_stack_len);
+TUNABLE_INT("security.pax.aslr.compat.stack", &pax_aslr_compat_exec_len);
+#endif
+
+
+#ifdef PAX_SYSCTLS
+/*
+ * sysctls and tunables
+ */
+static int sysctl_pax_aslr_debug(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_status(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_mmap(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_stack(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_exec(SYSCTL_HANDLER_ARGS);
+
+SYSCTL_DECL(_security_pax);
+
+SYSCTL_NODE(_security_pax, OID_AUTO, aslr, CTLFLAG_RD, 0,
+    "Address Space Layout Randomization.");
+
+SYSCTL_PROC(_security_pax_aslr, OID_AUTO, status,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_aslr_status, "I",
+    "Restrictions status. "
+    "0 - disabled, "
+    "1 - opt-in,  "
+    "2 - opt-out, "
+    "3 - force enabled");
+
+SYSCTL_PROC(_security_pax_aslr, OID_AUTO, debug,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_aslr_debug, "I",
+    "ASLR debug mode");
+
+SYSCTL_PROC(_security_pax_aslr, OID_AUTO, mmap_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_aslr_mmap, "I",
+    "Number of bits randomized for mmap(2) calls. "
+    "32 bit: [8,16] 64 bit: [16,32]");
+
+SYSCTL_PROC(_security_pax_aslr, OID_AUTO, stack_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_aslr_stack, "I",
+    "Number of bits randomized for the stack. "
+    "32 bit: [6,12] 64 bit: [12,21]");
+
+SYSCTL_PROC(_security_pax_aslr, OID_AUTO, exec_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_aslr_exec, "I",
+    "Number of bits randomized for the PIE exec base. "
+    "32 bit: [6,12] 64 bit: [12,21]");
+
+static int
+sysctl_pax_aslr_status(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_status : pax_aslr_status;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	switch (val) {
+	case    PAX_ASLR_DISABLED:
+	case    PAX_ASLR_OPTIN:
+	case    PAX_ASLR_OPTOUT:
+	case    PAX_ASLR_FORCE_ENABLED:
+		if ((pr == NULL) || (pr == &prison0)) {
+			pax_aslr_status = val;
+		}
+		if (pr != NULL) {
+			mtx_lock(&(pr->pr_mtx));
+			pr->pr_pax_aslr_status = val;
+			mtx_unlock(&(pr->pr_mtx));
+		}
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_debug(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr=NULL;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set)) {
+		pax_init_prison(pr);
+	}
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_debug : pax_aslr_debug;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr)
+		return (err);
+
+	switch (val) {
+	case	0:
+	case	1:
+		break;
+	default:
+		return (EINVAL);
+
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_debug = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_debug = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_mmap(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr=NULL;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set)) {
+		pax_init_prison(pr);
+	}
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_mmap_len : pax_aslr_mmap_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_DELTA_MMAP_MIN_LEN ||
+	    val > PAX_ASLR_DELTA_MMAP_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_mmap_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_mmap_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_stack(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr=NULL;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set)) {
+		pax_init_prison(pr);
+	}
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_stack_len : pax_aslr_stack_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_DELTA_STACK_MIN_LEN ||
+	    val > PAX_ASLR_DELTA_STACK_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_stack_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_stack_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_exec(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr=NULL;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set))
+		pax_init_prison(pr);
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_exec_len : pax_aslr_exec_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL)) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_DELTA_EXEC_MIN_LEN ||
+	    val > PAX_ASLR_DELTA_EXEC_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_exec_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_exec_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+/*
+ * COMPAT_FREEBSD32 and linuxulator..
+ */
+#ifdef COMPAT_FREEBSD32
+static int sysctl_pax_aslr_compat_status(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_compat_mmap(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_compat_stack(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_aslr_compat_exec(SYSCTL_HANDLER_ARGS);
+
+SYSCTL_NODE(_security_pax_aslr, OID_AUTO, compat, CTLFLAG_RD, 0,
+    "Setting for COMPAT_FREEBSD32 and linuxulator.");
+
+SYSCTL_PROC(_security_pax_aslr_compat, OID_AUTO, status,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON,
+    NULL, 0, sysctl_pax_aslr_compat_status, "I",
+    "Restrictions status. "
+    "0 - disabled, "
+    "1 - enabled,  "
+    "2 - global enabled, "
+    "3 - force global enabled");
+
+SYSCTL_PROC(_security_pax_aslr_compat, OID_AUTO, mmap_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON,
+    NULL, 0, sysctl_pax_aslr_compat_mmap, "I",
+    "Number of bits randomized for mmap(2) calls. "
+    "32 bit: [8,16]");
+
+SYSCTL_PROC(_security_pax_aslr_compat, OID_AUTO, stack_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON,
+    NULL, 0, sysctl_pax_aslr_compat_stack, "I",
+    "Number of bits randomized for the stack. "
+    "32 bit: [6,12]");
+
+SYSCTL_PROC(_security_pax_aslr_compat, OID_AUTO, exec_len,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON,
+    NULL, 0, sysctl_pax_aslr_compat_exec, "I",
+    "Number of bits randomized for the PIE exec base. "
+    "32 bit: [6,12]");
+
+static int
+sysctl_pax_aslr_compat_status(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ?pr->pr_pax_aslr_compat_status : pax_aslr_compat_status;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL)) {
+		return (err);
+	}
+
+	switch (val) {
+	case    PAX_ASLR_DISABLED:
+	case    PAX_ASLR_OPTIN:
+	case    PAX_ASLR_OPTOUT:
+	case    PAX_ASLR_FORCE_ENABLED:
+		if ((pr == NULL) || (pr == &prison0)) {
+			pax_aslr_compat_status = val;
+		}
+		if (pr != NULL) {
+			mtx_lock(&(pr->pr_mtx));
+			pr->pr_pax_aslr_compat_status = val;
+			mtx_unlock(&(pr->pr_mtx));
+		}
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_compat_mmap(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_compat_mmap_len : pax_aslr_compat_mmap_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_COMPAT_DELTA_MMAP_MIN_LEN ||
+	    val > PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_compat_mmap_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_compat_mmap_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_compat_stack(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_compat_stack_len : pax_aslr_compat_stack_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_COMPAT_DELTA_STACK_MIN_LEN ||
+	    val > PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_compat_stack_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_compat_stack_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_aslr_compat_exec(SYSCTL_HANDLER_ARGS)
+{
+	struct prison *pr;
+	int err, val;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_aslr_compat_exec_len : pax_aslr_compat_exec_len;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr) {
+		return (err);
+	}
+
+	if (val < PAX_ASLR_COMPAT_DELTA_EXEC_MIN_LEN ||
+	    val > PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN) {
+		return (EINVAL);
+	}
+
+	if ((pr == NULL) || (pr == &prison0)) {
+		pax_aslr_compat_exec_len = val;
+	}
+	if (pr != NULL) {
+		mtx_lock(&(pr->pr_mtx));
+		pr->pr_pax_aslr_compat_exec_len = val;
+		mtx_unlock(&(pr->pr_mtx));
+	}
+
+	return (0);
+}
+
+#endif /* COMPAT_FREEBSD32 */
+#endif /* PAX_SYSCTLS */
+
+
+/*
+ * ASLR functions
+ */
+bool
+pax_aslr_active(struct thread *td, struct proc *proc)
+{
+	int status;
+	struct prison *pr;
+	uint32_t flags;
+
+	if ((td == NULL) && (proc == NULL)) {
+		return (true);
+	}
+
+	pr = pax_get_prison(td, proc);
+
+	flags = (td != NULL) ? td->td_proc->p_pax : proc->p_pax;
+	if (((flags & 0xaaaaaaaa) & ((flags & 0x55555555) << 1)) != 0) {
+		pax_log_aslr(pr, __func__, "inconsistent paxflags: %x\n", flags);
+		pax_ulog_aslr(pr, NULL, "inconsistent paxflags: %x\n", flags);
+		return (true);
+	}
+
+	status = (pr != NULL) ? pr->pr_pax_aslr_status : pax_aslr_status;
+
+	switch (status) {
+	case    PAX_ASLR_DISABLED:
+		return (false);
+	case    PAX_ASLR_FORCE_ENABLED:
+		return (true);
+	case    PAX_ASLR_OPTIN:
+		if ((flags & PAX_NOTE_ASLR) == 0) {
+			pax_log_aslr(pr, __func__,
+			    "ASLR is opt-in, and executable does not have ASLR enabled\n");
+			pax_ulog_aslr(pr, NULL,
+			    "ASLR is opt-in, and executable does not have ASLR enabled\n");
+			return (false);
+		}
+		break;
+	case    PAX_ASLR_OPTOUT:
+		if ((flags & PAX_NOTE_NOASLR) != 0) {
+			pax_log_aslr(pr, __func__,
+			    "ASLR is opt-out, and executable explicitly disabled ASLR\n");
+			pax_ulog_aslr(pr, NULL,
+			    "ASLR is opt-out, and executable explicitly disabled ASLR\n");
+			return (false);
+		}
+		break;
+	default:
+		return (true);
+	}
+
+	return (true);
+}
+
+void
+_pax_aslr_init(struct vmspace *vm, struct prison *pr)
+{
+	if (vm == NULL) {
+		panic("[PaX ASLR] %s: vm == NULL", __func__);
+	}
+
+	vm->vm_aslr_delta_mmap = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_DELTA_MMAP_LSB, (pr != NULL) ? pr->pr_pax_aslr_mmap_len : pax_aslr_mmap_len);
+	vm->vm_aslr_delta_stack = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_DELTA_STACK_LSB, (pr != NULL) ? pr->pr_pax_aslr_stack_len : pax_aslr_stack_len);
+	vm->vm_aslr_delta_stack = ALIGN(vm->vm_aslr_delta_stack);
+	vm->vm_aslr_delta_exec = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_DELTA_EXEC_LSB, (pr != NULL) ? pr->pr_pax_aslr_exec_len : pax_aslr_exec_len);
+
+	if ((pr != NULL) && pr->pr_pax_aslr_debug) {
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_mmap=%p\n", (void *) vm->vm_aslr_delta_mmap);
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_stack=%p\n", (void *) vm->vm_aslr_delta_stack);
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_exec=%p\n", (void *) vm->vm_aslr_delta_exec);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_mmap=%p\n", (void *) vm->vm_aslr_delta_mmap);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_stack=%p\n", (void *) vm->vm_aslr_delta_stack);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_exec=%p\n", (void *) vm->vm_aslr_delta_exec);
+	}
+}
+
+#ifdef COMPAT_FREEBSD32
+void
+_pax_aslr_init32(struct vmspace *vm, struct prison *pr)
+{
+	if (vm == NULL) {
+		panic("[PaX ASLR] %s: vm == NULL", __func__);
+	}
+
+	vm->vm_aslr_delta_mmap = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_COMPAT_DELTA_MMAP_LSB, (pr != NULL) ? pr->pr_pax_aslr_compat_mmap_len : pax_aslr_compat_mmap_len);
+	vm->vm_aslr_delta_stack = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_COMPAT_DELTA_STACK_LSB, (pr != NULL) ? pr->pr_pax_aslr_compat_stack_len : pax_aslr_compat_stack_len);
+	vm->vm_aslr_delta_stack = ALIGN(vm->vm_aslr_delta_stack);
+	vm->vm_aslr_delta_exec = PAX_ASLR_DELTA(arc4random(),
+			PAX_ASLR_DELTA_EXEC_LSB, (pr != NULL) ? pr->pr_pax_aslr_compat_exec_len : pax_aslr_compat_exec_len);
+
+	if ((pr != NULL) && pr->pr_pax_aslr_debug) {
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_mmap=%p\n", (void *) vm->vm_aslr_delta_mmap);
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_stack=%p\n", (void *) vm->vm_aslr_delta_stack);
+		pax_log_aslr(pr, __func__, "vm_aslr_delta_exec=%p\n", (void *) vm->vm_aslr_delta_exec);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_mmap=%p\n", (void *) vm->vm_aslr_delta_mmap);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_stack=%p\n", (void *) vm->vm_aslr_delta_stack);
+		pax_ulog_aslr(pr, NULL, "vm_aslr_delta_exec=%p\n", (void *) vm->vm_aslr_delta_exec);
+	}
+}
+#endif
+
+void
+pax_aslr_init(struct thread *td, struct image_params *imgp)
+{
+	struct prison *pr;
+	struct vmspace *vm;
+
+	pr = pax_get_prison(td, NULL);
+
+	if (imgp == NULL) {
+		panic("[PaX ASLR] %s: imgp == NULL", __func__);
+	}
+
+	if (!pax_aslr_active(td, NULL)) {
+		return;
+	}
+
+	vm = imgp->proc->p_vmspace;
+
+	if (imgp->sysent->sv_pax_aslr_init != NULL) {
+		imgp->sysent->sv_pax_aslr_init(vm, pr);
+	}
+}
+
+void
+pax_aslr_mmap(struct thread *td, vm_offset_t *addr, vm_offset_t orig_addr, int flags)
+{
+	struct prison *pr;
+
+	if (!pax_aslr_active(td, NULL)) {
+		return;
+	}
+
+	pr = pax_get_prison(td, NULL);
+
+	if (!(flags & MAP_FIXED) && ((orig_addr == 0) || !(flags & MAP_ANON))) {
+		pax_log_aslr(pr, __func__, "applying to %p orig_addr=%p flags=%x\n",
+		    (void *)*addr, (void *)orig_addr, flags);
+
+		if (!(td->td_proc->p_vmspace->vm_map.flags & MAP_ENTRY_GROWS_DOWN))
+			*addr += td->td_proc->p_vmspace->vm_aslr_delta_mmap;
+		else
+			*addr -= td->td_proc->p_vmspace->vm_aslr_delta_mmap;
+		pax_log_aslr(pr, __func__, "result %p\n", (void *)*addr);
+	} else {
+		pax_log_aslr(pr, __func__, "not applying to %p orig_addr=%p flags=%x\n",
+		    (void *)*addr, (void *)orig_addr, flags);
+	}
+}
+
+void
+pax_aslr_stack(struct thread *td, uintptr_t *addr)
+{
+	struct prison *pr;
+	uintptr_t orig_addr;
+
+	if (!pax_aslr_active(td, NULL)) {
+		return;
+	}
+
+	pr = pax_get_prison(td, NULL);
+
+	orig_addr = *addr;
+	*addr -= td->td_proc->p_vmspace->vm_aslr_delta_stack;
+	pax_log_aslr(pr, __func__, "orig_addr=%p, new_addr=%p\n",
+	    (void *)orig_addr, (void *)*addr);
+	pax_ulog_aslr(pr, NULL, "orig_addr=%p, new_addr=%p\n",
+	    (void *)orig_addr, (void *)*addr);
+}
diff --git a/sys/kern/kern_pax_log.c b/sys/kern/kern_pax_log.c
new file mode 100644
index 0000000..89740d4
--- /dev/null
+++ b/sys/kern/kern_pax_log.c
@@ -0,0 +1,189 @@
+/*-
+ * Copyright (c) 2014, by Oliver Pinter <oliver.pntr at gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/types.h>
+#include <sys/kernel.h>
+#include <sys/pax.h>
+#include <sys/sbuf.h>
+#include <sys/jail.h>
+#include <machine/stdarg.h>
+
+#define __PAX_LOG_TEMPLATE(SUBJECT, name)					\
+void										\
+pax_log_##name(struct prison *pr, const char *caller_name, const char* fmt, ...)\
+{										\
+	struct sbuf *sb;							\
+	va_list args;								\
+										\
+	if ((pr != NULL) && (pr->pr_pax_log_log == 0))				\
+		return;								\
+										\
+	sb = sbuf_new_auto();							\
+	if (sb == NULL)								\
+		panic("%s: Could not allocate memory", __func__);		\
+	sbuf_printf(sb, "[PAX "#SUBJECT"] ");					\
+	if (caller_name != NULL)						\
+		sbuf_printf(sb, "%s: ", caller_name);				\
+	va_start(args, fmt);							\
+	sbuf_vprintf(sb, fmt, args);						\
+	va_end(args);								\
+	if (sbuf_finish(sb) != 0)						\
+		panic("%s: Could not generate message", __func__);		\
+										\
+	printf("%s", sbuf_data(sb));						\
+	sbuf_delete(sb);							\
+}										\
+										\
+void										\
+pax_ulog_##name(struct prison *pr, const char *caller_name, const char* fmt, ...)\
+{										\
+	struct sbuf *sb;							\
+	va_list args;								\
+										\
+	if ((pr != NULL) && (pr->pr_pax_log_ulog == 0))				\
+		return;								\
+										\
+	sb = sbuf_new_auto();							\
+	if (sb == NULL)								\
+		panic("%s: Could not allocate memory", __func__);		\
+	sbuf_printf(sb, "[PAX "#SUBJECT"] ");					\
+	if (caller_name != NULL)						\
+		sbuf_printf(sb, "%s: ", caller_name);				\
+	va_start(args, fmt);							\
+	sbuf_vprintf(sb, fmt, args);						\
+	va_end(args);								\
+	if (sbuf_finish(sb) != 0)						\
+		panic("%s: Could not generate message", __func__);		\
+										\
+	uprintf("%s", sbuf_data(sb));						\
+	sbuf_delete(sb);							\
+}
+
+
+static int sysctl_pax_log_log(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_log_ulog(SYSCTL_HANDLER_ARGS);
+
+int pax_log_log = PAX_LOG_LOG;
+int pax_log_ulog = PAX_LOG_ULOG;
+
+SYSCTL_DECL(_security_pax);
+
+SYSCTL_NODE(_security_pax, OID_AUTO, log, CTLFLAG_RD, 0,
+    "PAX related logging facility.");
+
+SYSCTL_PROC(_security_pax_log, OID_AUTO, log,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_log_log, "I",
+    "log to syslog "
+    "0 - disabled, "
+    "1 - enabled ");
+TUNABLE_INT("security.pax.log.log", &pax_log_log);
+
+SYSCTL_PROC(_security_pax_log, OID_AUTO, ulog,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_log_ulog, "I",
+    "log to user terminal"
+    "0 - disabled, "
+    "1 - enabled ");
+TUNABLE_INT("security.pax.log.ulog", &pax_log_ulog);
+
+static int
+sysctl_pax_log_log(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr=NULL;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set))
+		pax_init_prison(pr);
+
+	val = (pr != NULL) ? pr->pr_pax_log_log : pax_log_log;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr)
+		return (err);
+
+	switch (val) {
+	case	0:
+	case	1:
+		break;
+	default:
+		return (EINVAL);
+
+	}
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_log_log = val;
+	if (pr != NULL)
+		pr->pr_pax_log_log = val;
+
+	return (0);
+}
+
+static int
+sysctl_pax_log_ulog(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr=NULL;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	if ((pr != NULL) && !(pr->pr_pax_set))
+		pax_init_prison(pr);
+
+	val = (pr != NULL) ? pr->pr_pax_log_ulog : pax_log_ulog;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || !req->newptr)
+		return (err);
+
+	switch (val) {
+	case	0:
+	case	1:
+		break;
+	default:
+		return (EINVAL);
+
+	}
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_log_ulog = val;
+	if (pr != NULL)
+		pr->pr_pax_log_ulog = val;
+
+	return (0);
+}
+
+
+__PAX_LOG_TEMPLATE(ASLR, aslr)
+__PAX_LOG_TEMPLATE(SEGVGUARD, segvguard)
diff --git a/sys/kern/kern_pax_segvguard.c b/sys/kern/kern_pax_segvguard.c
new file mode 100644
index 0000000..0533d1a
--- /dev/null
+++ b/sys/kern/kern_pax_segvguard.c
@@ -0,0 +1,462 @@
+/*-
+ * Copyright (c) 2006 Elad Efrat <elad@NetBSD.org>
+ * Copyright (c) 2013-2014, by Oliver Pinter <oliver.pntr at gmail.com>
+ * Copyright (c) 2014, by Shawn Webb <lattera at gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_compat.h"
+#include "opt_pax.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/imgact.h>
+#include <sys/imgact_elf.h>
+#include <sys/sysent.h>
+#include <sys/stat.h>
+#include <sys/proc.h>
+#include <sys/elf_common.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <sys/vnode.h>
+#include <sys/queue.h>
+#include <sys/libkern.h>
+#include <sys/jail.h>
+#include <sys/fnv_hash.h>
+
+#include <sys/mman.h>
+#include <sys/libkern.h>
+#include <sys/exec.h>
+#include <sys/kthread.h>
+
+#include <vm/pmap.h>
+#include <vm/vm_map.h>
+#include <vm/vm_extern.h>
+
+#include <machine/elf.h>
+
+#include <sys/pax.h>
+
+int pax_segvguard_status = PAX_SEGVGUARD_OPTIN;
+int pax_segvguard_debug = 0;
+int pax_segvguard_expiry = PAX_SEGVGUARD_EXPIRY;
+int pax_segvguard_suspension = PAX_SEGVGUARD_SUSPENSION;
+int pax_segvguard_maxcrashes = PAX_SEGVGUARD_MAXCRASHES;
+
+
+struct pax_segvguard_entry {
+	uid_t se_uid;
+	ino_t se_inode;
+	char se_mntpoint[MNAMELEN];
+
+	size_t se_ncrashes;
+	sbintime_t se_expiry;
+	sbintime_t se_suspended;
+	LIST_ENTRY(pax_segvguard_entry) se_entry;
+};
+
+static struct pax_segvguard_key {
+	uid_t se_uid;
+	ino_t se_inode;
+	char se_mntpoint[MNAMELEN];
+} *key;
+
+LIST_HEAD(pax_segvguard_entryhead, pax_segvguard_entry);
+
+static struct pax_segvguard_entryhead *pax_segvguard_hashtbl;
+static u_long pax_segvguard_hashmask;
+static int pax_segvguard_hashsize = 512;
+
+#define PAX_SEGVGUARD_HASHVAL(x) \
+	fnv_32_buf((&(x)), sizeof(x), FNV1_32_INIT)
+
+#define PAX_SEGVGUARD_HASH(x) \
+	(&pax_segvguard_hashtbl[PAX_SEGVGUARD_HASHVAL(x) & pax_segvguard_hashmask])
+
+#define PAX_SEGVGUARD_KEY(x) \
+	((struct pax_segvguard_key *) x)
+
+MALLOC_DECLARE(M_PAX);
+MALLOC_DEFINE(M_PAX, "pax_segvguard", "PaX segvguard memory");
+
+struct mtx segvguard_mtx;
+
+static int sysctl_pax_segvguard_status(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_segvguard_debug(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_segvguard_expiry(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_segvguard_suspension(SYSCTL_HANDLER_ARGS);
+static int sysctl_pax_segvguard_maxcrashes(SYSCTL_HANDLER_ARGS);
+
+SYSCTL_DECL(_security_pax);
+
+SYSCTL_NODE(_security_pax, OID_AUTO, segvguard, CTLFLAG_RD, 0, "PaX segvguard");
+
+SYSCTL_PROC(_security_pax_segvguard, OID_AUTO, status,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_segvguard_status, "I",
+    "Guard status. "
+    "0 - disabled, "
+    "1 - opt-in,  "
+    "2 - opt-out, "
+    "3 - force enabled");
+TUNABLE_INT("security.pax.segvguard.status", &pax_segvguard_status);
+
+SYSCTL_PROC(_security_pax_segvguard, OID_AUTO, debug,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_segvguard_debug, "I",
+    "Debug mode.");
+TUNABLE_INT("security.pax.segvguard.debug", &pax_segvguard_debug);
+
+SYSCTL_PROC(_security_pax_segvguard, OID_AUTO, expiry_timeout,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_segvguard_expiry, "I",
+    "Entry expiry timeout (in seconds).");
+TUNABLE_INT("security.pax.segvguard.expiry_timeout", &pax_segvguard_expiry);
+
+SYSCTL_PROC(_security_pax_segvguard, OID_AUTO, suspend_timeout,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_segvguard_suspension, "I",
+    "Entry suspension timeout (in seconds).");
+TUNABLE_INT("security.pax.segvguard.suspend_timeout", &pax_segvguard_suspension);
+
+SYSCTL_PROC(_security_pax_segvguard, OID_AUTO, max_crashes,
+    CTLTYPE_INT|CTLFLAG_RWTUN|CTLFLAG_PRISON|CTLFLAG_SECURE,
+    NULL, 0, sysctl_pax_segvguard_maxcrashes, "I",
+    "Max number of crashes before expiry.");
+TUNABLE_INT("security.pax.segvguard.max_crashes", &pax_segvguard_maxcrashes);
+
+static int
+sysctl_pax_segvguard_status(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_segvguard_status : pax_segvguard_status;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	switch (val) {
+	case    PAX_SEGVGUARD_DISABLED:
+	case    PAX_SEGVGUARD_OPTIN:
+	case    PAX_SEGVGUARD_OPTOUT:
+	case    PAX_SEGVGUARD_FORCE_ENABLED:
+		if ((pr == NULL) || (pr == &prison0))
+			pax_segvguard_status = val;
+		if (pr != NULL)
+			pr->pr_pax_segvguard_status = val;
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	return (0);
+}
+
+static int
+sysctl_pax_segvguard_expiry(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_segvguard_expiry : pax_segvguard_expiry;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_segvguard_expiry = val;
+	if (pr != NULL)
+		pr->pr_pax_segvguard_expiry = val;
+
+	return (0);
+}
+
+static int
+sysctl_pax_segvguard_suspension(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_segvguard_suspension : pax_segvguard_suspension;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_segvguard_suspension = val;
+	if (pr != NULL)
+		pr->pr_pax_segvguard_suspension = val;
+
+	return (0);
+}
+
+static int
+sysctl_pax_segvguard_maxcrashes(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_segvguard_maxcrashes : pax_segvguard_maxcrashes;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_segvguard_maxcrashes = val;
+	if (pr != NULL)
+		pr->pr_pax_segvguard_maxcrashes = val;
+
+	return (0);
+}
+
+static int
+sysctl_pax_segvguard_debug(SYSCTL_HANDLER_ARGS)
+{
+	int err;
+	int val;
+	struct prison *pr;
+
+	pr = pax_get_prison(req->td, NULL);
+
+	val = (pr != NULL) ? pr->pr_pax_segvguard_debug : pax_segvguard_debug;
+	err = sysctl_handle_int(oidp, &val, sizeof(int), req);
+	if (err || (req->newptr == NULL))
+		return (err);
+
+	if ((pr == NULL) || (pr == &prison0))
+		pax_segvguard_debug = val;
+	if (pr != NULL)
+		pr->pr_pax_segvguard_debug = val;
+
+	return (0);
+}
+
+
+static bool
+pax_segvguard_active(struct thread *td, struct vnode *vn, struct proc *proc)
+{
+	int status;
+	struct prison *pr;
+	struct vattr vap;
+	uint32_t flags;
+
+	if ((td == NULL) && (proc == NULL))
+		return (true);
+
+	flags = (td != NULL) ? td->td_proc->p_pax : proc->p_pax;
+	if (((flags & 0xaaaaaaaa) & ((flags & 0x55555555) << 1)) != 0) {
+		uprintf("PAX: inconsistent paxflags: %x\n", flags);
+		return (true);
+	}
+
+	pr = pax_get_prison(td, proc);
+
+	status = (pr != NULL) ? pr->pr_pax_segvguard_status : pax_segvguard_status;
+
+	VOP_GETATTR(vn, &vap, td->td_ucred);
+
+	switch (status) {
+	case    PAX_SEGVGUARD_DISABLED:
+		return (false);
+	case    PAX_SEGVGUARD_FORCE_ENABLED:
+		return (true);
+	case    PAX_SEGVGUARD_OPTIN:
+		/* TODO: The ugidfw flags isn't working */
+		if ((vap.va_mode & (S_ISUID | S_ISGID)) == 0)
+			return (false);
+		break;
+	case    PAX_SEGVGUARD_OPTOUT:
+		if (flags && (flags & PAX_NOTE_NOGUARD) != 0)
+			return (false);
+		break;
+	default:
+		return (true);
+	}
+
+	return (true);
+}
+
+static struct pax_segvguard_entry *
+pax_segvguard_add(struct thread *td, struct stat *sb, struct vnode *vn, sbintime_t sbt)
+{
+	struct pax_segvguard_entry *v;
+	struct prison *pr;
+
+	pr = pax_get_prison(td, NULL);
+
+	v = malloc(sizeof(struct pax_segvguard_entry), M_PAX, M_NOWAIT);
+	if (!v)
+		return (NULL);
+
+	v->se_inode = sb->st_ino;
+	strncpy(v->se_mntpoint, vn->v_mount->mnt_stat.f_mntonname, MNAMELEN);
+
+	v->se_uid = td->td_ucred->cr_uid;
+	v->se_ncrashes = 1;
+	v->se_expiry = sbt + ((pr != NULL) ? pr->pr_pax_segvguard_expiry : pax_segvguard_expiry) * SBT_1S;
+	v->se_suspended = 0;
+
+	key = PAX_SEGVGUARD_KEY(v);
+	LIST_INSERT_HEAD(PAX_SEGVGUARD_HASH(*key), v, se_entry);
+
+	return (v);
+}
+
+static struct pax_segvguard_entry *
+pax_segvguard_lookup(struct thread *td, struct stat *sb, struct vnode *vn)
+{
+	struct pax_segvguard_entry *v;
+	struct pax_segvguard_key sk;
+	struct prison *pr;
+
+	pr = pax_get_prison(td, NULL);
+
+	sk.se_inode = sb->st_ino;
+	strncpy(sk.se_mntpoint, vn->v_mount->mnt_stat.f_mntonname, MNAMELEN);
+	sk.se_uid = td->td_ucred->cr_uid;
+
+	LIST_FOREACH(v, PAX_SEGVGUARD_HASH(sk), se_entry) {
+		if (v->se_inode == sb->st_ino &&
+		    !strncmp(sk.se_mntpoint, v->se_mntpoint, MNAMELEN) &&
+		    td->td_ucred->cr_uid == v->se_uid) {
+
+			return (v);
+		}
+	}
+
+	return (NULL);
+}
+
+int
+pax_segvguard(struct thread *td, struct vnode *v, char *name, bool crashed)
+{
+	struct pax_segvguard_entry *se;
+	struct prison *pr;
+	struct stat sb;
+	sbintime_t sbt;
+
+	if (v == NULL)
+		return (EFAULT);
+
+	pr = pax_get_prison(td, NULL);
+
+	vn_stat(v, &sb, td->td_ucred, NOCRED, curthread);
+
+	if (pax_segvguard_active(td, v, NULL) == false)
+		return (0);
+
+	sbt = sbinuptime();
+
+	mtx_lock(&segvguard_mtx);
+
+	se = pax_segvguard_lookup(td, &sb, v);
+
+	if (!crashed && se == NULL) {
+
+		mtx_unlock(&segvguard_mtx);
+		return (0);
+	}
+
+	if (!crashed && se != NULL) {
+		if (se->se_suspended > sbt) {
+			printf("PaX Segvguard: [%s (%d)] Preventing "
+					"execution due to repeated segfaults.\n", name, td->td_proc->p_pid);
+
+			mtx_unlock(&segvguard_mtx);
+			return (EPERM);
+		}
+	}
+
+	/*
+	 * If a program we don't know about crashed, we need to create a new entry for it
+	 */
+	if (crashed && se == NULL) {
+		pax_segvguard_add(td, &sb, v, sbt);
+
+		mtx_unlock(&segvguard_mtx);
+		return (0);
+	}
+
+	if (crashed && se != NULL) {
+		if (se->se_expiry < sbt && se->se_suspended <= sbt) {
+			printf("PaX Segvguard: [%s (%d)] Suspension "
+					"expired.\n", name, td->td_proc->p_pid);
+			se->se_ncrashes = 1;
+			se->se_expiry = sbt + ((pr != NULL) ? pr->pr_pax_segvguard_expiry : pax_segvguard_expiry) * SBT_1S;
+			se->se_suspended = 0;
+
+			mtx_unlock(&segvguard_mtx);
+			return (0);
+		}
+
+		se->se_ncrashes++;
+
+		if (se->se_ncrashes >= pax_segvguard_maxcrashes) {
+			printf("PaX Segvguard: [%s (%d)] Suspending "
+					"execution for %d seconds after %zu crashes.\n",
+					name, td->td_proc->p_pid,
+					pax_segvguard_suspension, se->se_ncrashes);
+			se->se_suspended = sbt + ((pr != NULL) ? pr->pr_pax_segvguard_suspension : pax_segvguard_suspension) * SBT_1S;
+			se->se_ncrashes = 0;
+			se->se_expiry = 0;
+		}
+
+		mtx_unlock(&segvguard_mtx);
+		return (0);
+	}
+
+	mtx_unlock(&segvguard_mtx);
+	return (0);
+}
+
+static void
+pax_segvguard_init(void)
+{
+
+	mtx_init(&segvguard_mtx, "segvguard mutex", NULL, MTX_DEF);
+
+	pax_segvguard_hashtbl = hashinit(pax_segvguard_hashsize, M_PAX, &pax_segvguard_hashmask);
+}
+
+SYSINIT(pax_segvguard_init, SI_SUB_LOCK, SI_ORDER_ANY, pax_segvguard_init, NULL);
diff --git a/sys/kern/kern_sig.c b/sys/kern/kern_sig.c
index b405779..3569570 100644
--- a/sys/kern/kern_sig.c
+++ b/sys/kern/kern_sig.c
@@ -40,6 +40,7 @@ __FBSDID("$FreeBSD$");
 #include "opt_compat.h"
 #include "opt_ktrace.h"
 #include "opt_core.h"
+#include "opt_pax.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -88,6 +89,10 @@ __FBSDID("$FreeBSD$");
 
 #include <security/audit/audit.h>
 
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+#include <sys/pax.h>
+#endif
+
 #define	ONSIG	32		/* NSIG for osig* syscalls.  XXX. */
 
 SDT_PROVIDER_DECLARE(proc);
@@ -2924,8 +2929,22 @@ sigexit(td, sig)
 			    td->td_ucred ? td->td_ucred->cr_uid : -1,
 			    sig &~ WCOREFLAG,
 			    sig & WCOREFLAG ? " (core dumped)" : "");
-	} else
+#ifdef PAX_SEGVGUARD
+		pax_segvguard(curthread, curthread->td_proc->p_textvp, 
+				p->p_comm, PAX_SEGVGUARD_CRASHED);
+#endif
+	} else {
+		/*
+		 *  XXX-op
+		 *
+		 * pax_segvguard(curthread, curthread->td_proc->p_textvp,
+		 * 	 p->p_comm, PAX_SEGVGUARD_CLEANUP_IF_CRASHED_NOT_FOUND);
+		 *
+		 * aka: Clean up the properly exited thread, instead of running a GC?
+		 */
 		PROC_UNLOCK(p);
+	}
+
 	exit1(td, W_EXITCODE(0, sig));
 	/* NOTREACHED */
 }
diff --git a/sys/mips/mips/elf_machdep.c b/sys/mips/mips/elf_machdep.c
index d374713..f95ba35 100644
--- a/sys/mips/mips/elf_machdep.c
+++ b/sys/mips/mips/elf_machdep.c
@@ -28,6 +28,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -49,6 +51,10 @@ __FBSDID("$FreeBSD$");
 #include <machine/md_var.h>
 #include <machine/cache.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 #ifdef __mips_n64
 struct sysentvec elf64_freebsd_sysvec = {
 	.sv_size	= SYS_MAXSYSCALL,
@@ -83,6 +89,11 @@ struct sysentvec elf64_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 static Elf64_Brandinfo freebsd_brand_info = {
@@ -139,6 +150,11 @@ struct sysentvec elf32_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 static Elf32_Brandinfo freebsd_brand_info = {
diff --git a/sys/mips/mips/freebsd32_machdep.c b/sys/mips/mips/freebsd32_machdep.c
index dfdf70f..103ad84 100644
--- a/sys/mips/mips/freebsd32_machdep.c
+++ b/sys/mips/mips/freebsd32_machdep.c
@@ -31,6 +31,7 @@
  */
 
 #include "opt_compat.h"
+#include "opt_pax.h"
 
 #define __ELF_WORD_SIZE 32
 
@@ -66,6 +67,10 @@
 #include <compat/freebsd32/freebsd32_util.h>
 #include <compat/freebsd32/freebsd32_proto.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 static void freebsd32_exec_setregs(struct thread *, struct image_params *, u_long);
 static int get_mcontext32(struct thread *, mcontext32_t *, int);
 static int set_mcontext32(struct thread *, const mcontext32_t *);
@@ -106,6 +111,11 @@ struct sysentvec elf32_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = freebsd32_syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf32_sysvec, &elf32_freebsd_sysvec);
 
diff --git a/sys/powerpc/powerpc/elf32_machdep.c b/sys/powerpc/powerpc/elf32_machdep.c
index dbe58df..229fe97 100644
--- a/sys/powerpc/powerpc/elf32_machdep.c
+++ b/sys/powerpc/powerpc/elf32_machdep.c
@@ -25,6 +25,8 @@
  * $FreeBSD$
  */
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -52,6 +54,10 @@
 #include <machine/reg.h>
 #include <machine/md_var.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 #ifdef __powerpc64__
 #include <compat/freebsd32/freebsd32_proto.h>
 #include <compat/freebsd32/freebsd32_util.h>
@@ -107,6 +113,11 @@ struct sysentvec elf32_freebsd_sysvec = {
 	.sv_shared_page_base = FREEBSD32_SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init32,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf32_sysvec, &elf32_freebsd_sysvec);
 
diff --git a/sys/powerpc/powerpc/elf64_machdep.c b/sys/powerpc/powerpc/elf64_machdep.c
index 0c41a8d..095f37b0 100644
--- a/sys/powerpc/powerpc/elf64_machdep.c
+++ b/sys/powerpc/powerpc/elf64_machdep.c
@@ -25,6 +25,8 @@
  * $FreeBSD$
  */
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -48,6 +50,10 @@
 #include <machine/elf.h>
 #include <machine/md_var.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 struct sysentvec elf64_freebsd_sysvec = {
 	.sv_size	= SYS_MAXSYSCALL,
 	.sv_table	= sysent,
@@ -83,6 +89,11 @@ struct sysentvec elf64_freebsd_sysvec = {
 	.sv_shared_page_base = SHAREDPAGE,
 	.sv_shared_page_len = PAGE_SIZE,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 INIT_SYSENTVEC(elf64_sysvec, &elf64_freebsd_sysvec);
 
diff --git a/sys/security/mac_bsdextended/mac_bsdextended.c b/sys/security/mac_bsdextended/mac_bsdextended.c
index ccbc525..9f8a191 100644
--- a/sys/security/mac_bsdextended/mac_bsdextended.c
+++ b/sys/security/mac_bsdextended/mac_bsdextended.c
@@ -47,6 +47,8 @@
  * firewall-like rules regarding users and file system objects.
  */
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/acl.h>
 #include <sys/kernel.h>
@@ -56,14 +58,20 @@
 #include <sys/module.h>
 #include <sys/mount.h>
 #include <sys/mutex.h>
+#include <sys/param.h>
 #include <sys/priv.h>
 #include <sys/proc.h>
 #include <sys/systm.h>
 #include <sys/vnode.h>
 #include <sys/sysctl.h>
 #include <sys/syslog.h>
+#include <sys/syslimits.h>
 #include <sys/stat.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 #include <security/mac/mac_policy.h>
 #include <security/mac_bsdextended/mac_bsdextended.h>
 #include <security/mac_bsdextended/ugidfw_internal.h>
@@ -117,7 +125,6 @@ SYSCTL_INT(_security_mac_bsdextended, OID_AUTO, firstmatch_enabled,
 static int
 ugidfw_rule_valid(struct mac_bsdextended_rule *rule)
 {
-
 	if ((rule->mbr_subject.mbs_flags | MBS_ALL_FLAGS) != MBS_ALL_FLAGS)
 		return (EINVAL);
 	if ((rule->mbr_subject.mbs_neg | MBS_ALL_FLAGS) != MBS_ALL_FLAGS)
@@ -129,8 +136,13 @@ ugidfw_rule_valid(struct mac_bsdextended_rule *rule)
 	if ((rule->mbr_object.mbo_neg | MBO_TYPE_DEFINED) &&
 	    (rule->mbr_object.mbo_type | MBO_ALL_TYPE) != MBO_ALL_TYPE)
 		return (EINVAL);
+#ifdef PAX_ASLR
+	if ((rule->mbr_pax | MBI_ALLPAX) != MBI_ALLPAX)
+		return (EINVAL);
+#endif
 	if ((rule->mbr_mode | MBI_ALLPERM) != MBI_ALLPERM)
 		return (EINVAL);
+
 	return (0);
 }
 
@@ -227,7 +239,7 @@ ugidfw_destroy(struct mac_policy_conf *mpc)
 
 static int
 ugidfw_rulecheck(struct mac_bsdextended_rule *rule,
-    struct ucred *cred, struct vnode *vp, struct vattr *vap, int acc_mode)
+    struct ucred *cred, struct vnode *vp, struct vattr *vap, int acc_mode, struct image_params *imgp)
 {
 	int mac_granted, match, priv_granted;
 	int i;
@@ -305,6 +317,10 @@ ugidfw_rulecheck(struct mac_bsdextended_rule *rule,
 		match = (bcmp(&(vp->v_mount->mnt_stat.f_fsid),
 		    &(rule->mbr_object.mbo_fsid),
 		    sizeof(rule->mbr_object.mbo_fsid)) == 0);
+#if defined(PAX_ASLR) || defined(PAX_SEGVGUARD)
+		if (match && rule->mbr_object.mbo_inode)
+			match = (vap->va_fileid == rule->mbr_object.mbo_inode);
+#endif
 		if (rule->mbr_object.mbo_neg & MBO_FSID_DEFINED)
 			match = !match;
 		if (!match)
@@ -413,6 +429,11 @@ ugidfw_rulecheck(struct mac_bsdextended_rule *rule,
 		return (EACCES);
 	}
 
+#ifdef PAX_ASLR
+	if (imgp != NULL)
+		pax_elf(imgp, rule->mbr_pax);
+#endif
+
 	/*
 	 * If the rule matched, permits access, and first match is enabled,
 	 * return success.
@@ -425,7 +446,7 @@ ugidfw_rulecheck(struct mac_bsdextended_rule *rule,
 
 int
 ugidfw_check(struct ucred *cred, struct vnode *vp, struct vattr *vap,
-    int acc_mode)
+    int acc_mode, struct image_params *imgp)
 {
 	int error, i;
 
@@ -441,7 +462,7 @@ ugidfw_check(struct ucred *cred, struct vnode *vp, struct vattr *vap,
 		if (rules[i] == NULL)
 			continue;
 		error = ugidfw_rulecheck(rules[i], cred,
-		    vp, vap, acc_mode);
+		    vp, vap, acc_mode, imgp);
 		if (error == EJUSTRETURN)
 			break;
 		if (error) {
@@ -454,7 +475,7 @@ ugidfw_check(struct ucred *cred, struct vnode *vp, struct vattr *vap,
 }
 
 int
-ugidfw_check_vp(struct ucred *cred, struct vnode *vp, int acc_mode)
+ugidfw_check_vp(struct ucred *cred, struct vnode *vp, int acc_mode, struct image_params *imgp)
 {
 	int error;
 	struct vattr vap;
@@ -464,7 +485,7 @@ ugidfw_check_vp(struct ucred *cred, struct vnode *vp, int acc_mode)
 	error = VOP_GETATTR(vp, &vap, cred);
 	if (error)
 		return (error);
-	return (ugidfw_check(cred, vp, &vap, acc_mode));
+	return (ugidfw_check(cred, vp, &vap, acc_mode, imgp));
 }
 
 int
diff --git a/sys/security/mac_bsdextended/mac_bsdextended.h b/sys/security/mac_bsdextended/mac_bsdextended.h
index c09abc0..8026a57 100644
--- a/sys/security/mac_bsdextended/mac_bsdextended.h
+++ b/sys/security/mac_bsdextended/mac_bsdextended.h
@@ -51,6 +51,12 @@
 #define	MBI_ADMIN	010000
 #define	MBI_STAT	020000
 #define	MBI_APPEND	040000
+#define MBI_FORCE_ASLR_ENABLED          0x01
+#define MBI_FORCE_ASLR_DISABLED         0x02
+#define MBI_FORCE_SEGVGUARD_ENABLED     0x04
+#define MBI_FORCE_SEGVGUARD_DISABLED    0x08
+#define MBI_ALLPAX (MBI_FORCE_ASLR_ENABLED | MBI_FORCE_ASLR_DISABLED | \
+        MBI_FORCE_SEGVGUARD_ENABLED | MBI_FORCE_SEGVGUARD_DISABLED)
 #define	MBI_ALLPERM	(MBI_EXEC | MBI_WRITE | MBI_READ | MBI_ADMIN | \
 			    MBI_STAT | MBI_APPEND)
 
@@ -78,6 +84,7 @@ struct mac_bsdextended_subject {
 #define	MBO_UID_SUBJECT	0x00000020	/* uid must match subject */
 #define	MBO_GID_SUBJECT	0x00000040	/* gid must match subject */
 #define	MBO_TYPE_DEFINED 0x00000080	/* object type should be matched */
+#define MBO_PAXPATH_DEFINED 0x00000100 /* TODO: paxpath should be matched */
 
 #define MBO_ALL_FLAGS (MBO_UID_DEFINED | MBO_GID_DEFINED | MBO_FSID_DEFINED | \
 	    MBO_SUID | MBO_SGID | MBO_UID_SUBJECT | MBO_GID_SUBJECT | \
@@ -103,12 +110,15 @@ struct mac_bsdextended_object {
 	gid_t	mbo_gid_max;
 	struct fsid mbo_fsid;
 	int	mbo_type;
+	ino_t	mbo_inode;
+	char	mbo_paxpath[MAXPATHLEN];
 };
 
 struct mac_bsdextended_rule {
 	struct mac_bsdextended_subject	mbr_subject;
 	struct mac_bsdextended_object	mbr_object;
 	mode_t				mbr_mode;	/* maximum access */
+	uint32_t			mbr_pax;
 };
 
 #endif /* _SYS_SECURITY_MAC_BSDEXTENDED_H */
diff --git a/sys/security/mac_bsdextended/ugidfw_internal.h b/sys/security/mac_bsdextended/ugidfw_internal.h
index 5597fd1..ef98274 100644
--- a/sys/security/mac_bsdextended/ugidfw_internal.h
+++ b/sys/security/mac_bsdextended/ugidfw_internal.h
@@ -36,8 +36,8 @@
  */
 int	ugidfw_accmode2mbi(accmode_t accmode);
 int	ugidfw_check(struct ucred *cred, struct vnode *vp, struct vattr *vap,
-	    int acc_mode);
-int	ugidfw_check_vp(struct ucred *cred, struct vnode *vp, int acc_mode);
+	    int acc_mode, struct image_params *imgp);
+int	ugidfw_check_vp(struct ucred *cred, struct vnode *vp, int acc_mode, struct image_params *imgp);
 
 /*
  * System access control checks.
diff --git a/sys/security/mac_bsdextended/ugidfw_system.c b/sys/security/mac_bsdextended/ugidfw_system.c
index 49e4f1d..2829a00 100644
--- a/sys/security/mac_bsdextended/ugidfw_system.c
+++ b/sys/security/mac_bsdextended/ugidfw_system.c
@@ -66,7 +66,7 @@ ugidfw_system_check_acct(struct ucred *cred, struct vnode *vp,
 {
 
 	if (vp != NULL)
-		return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+		return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 	else
 		return (0);
 }
@@ -77,7 +77,7 @@ ugidfw_system_check_auditctl(struct ucred *cred, struct vnode *vp,
 {
 
 	if (vp != NULL)
-		return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+		return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 	else
 		return (0);
 }
@@ -87,5 +87,5 @@ ugidfw_system_check_swapon(struct ucred *cred, struct vnode *vp,
     struct label *vplabel)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 }
diff --git a/sys/security/mac_bsdextended/ugidfw_vnode.c b/sys/security/mac_bsdextended/ugidfw_vnode.c
index 8ec2d48..2065e6e 100644
--- a/sys/security/mac_bsdextended/ugidfw_vnode.c
+++ b/sys/security/mac_bsdextended/ugidfw_vnode.c
@@ -65,7 +65,7 @@ ugidfw_vnode_check_access(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, accmode_t accmode)
 {
 
-	return (ugidfw_check_vp(cred, vp, ugidfw_accmode2mbi(accmode)));
+	return (ugidfw_check_vp(cred, vp, ugidfw_accmode2mbi(accmode), NULL));
 }
 
 int
@@ -73,7 +73,7 @@ ugidfw_vnode_check_chdir(struct ucred *cred, struct vnode *dvp,
     struct label *dvplabel)
 {
 
-	return (ugidfw_check_vp(cred, dvp, MBI_EXEC));
+	return (ugidfw_check_vp(cred, dvp, MBI_EXEC, NULL));
 }
 
 int
@@ -81,7 +81,7 @@ ugidfw_vnode_check_chroot(struct ucred *cred, struct vnode *dvp,
     struct label *dvplabel)
 {
 
-	return (ugidfw_check_vp(cred, dvp, MBI_EXEC));
+	return (ugidfw_check_vp(cred, dvp, MBI_EXEC, NULL));
 }
 
 int
@@ -89,7 +89,7 @@ ugidfw_check_create_vnode(struct ucred *cred, struct vnode *dvp,
     struct label *dvplabel, struct componentname *cnp, struct vattr *vap)
 {
 
-	return (ugidfw_check_vp(cred, dvp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, dvp, MBI_WRITE, NULL));
 }
 
 int
@@ -97,7 +97,7 @@ ugidfw_vnode_check_deleteacl(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, acl_type_t type)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -105,7 +105,7 @@ ugidfw_vnode_check_deleteextattr(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, int attrnamespace, const char *name)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 }
 
 int
@@ -114,7 +114,7 @@ ugidfw_vnode_check_exec(struct ucred *cred, struct vnode *vp,
     struct label *execlabel)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_READ|MBI_EXEC));
+	return (ugidfw_check_vp(cred, vp, MBI_READ|MBI_EXEC, imgp));
 }
 
 int
@@ -122,7 +122,7 @@ ugidfw_vnode_check_getacl(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, acl_type_t type)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_STAT));
+	return (ugidfw_check_vp(cred, vp, MBI_STAT, NULL));
 }
 
 int
@@ -130,7 +130,7 @@ ugidfw_vnode_check_getextattr(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, int attrnamespace, const char *name)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_READ));
+	return (ugidfw_check_vp(cred, vp, MBI_READ, NULL));
 }
 
 int
@@ -140,10 +140,10 @@ ugidfw_vnode_check_link(struct ucred *cred, struct vnode *dvp,
 {
 	int error;
 
-	error = ugidfw_check_vp(cred, dvp, MBI_WRITE);
+	error = ugidfw_check_vp(cred, dvp, MBI_WRITE, NULL);
 	if (error)
 		return (error);
-	error = ugidfw_check_vp(cred, vp, MBI_WRITE);
+	error = ugidfw_check_vp(cred, vp, MBI_WRITE, NULL);
 	if (error)
 		return (error);
 	return (0);
@@ -154,7 +154,7 @@ ugidfw_vnode_check_listextattr(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, int attrnamespace)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_READ));
+	return (ugidfw_check_vp(cred, vp, MBI_READ, NULL));
 }
 
 int
@@ -162,7 +162,7 @@ ugidfw_vnode_check_lookup(struct ucred *cred, struct vnode *dvp,
     struct label *dvplabel, struct componentname *cnp)
 {
 
-	return (ugidfw_check_vp(cred, dvp, MBI_EXEC));
+	return (ugidfw_check_vp(cred, dvp, MBI_EXEC, NULL));
 }
 
 int
@@ -170,7 +170,7 @@ ugidfw_vnode_check_open(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, accmode_t accmode)
 {
 
-	return (ugidfw_check_vp(cred, vp, ugidfw_accmode2mbi(accmode)));
+	return (ugidfw_check_vp(cred, vp, ugidfw_accmode2mbi(accmode), NULL));
 }
 
 int
@@ -178,7 +178,7 @@ ugidfw_vnode_check_readdir(struct ucred *cred, struct vnode *dvp,
     struct label *dvplabel)
 {
 
-	return (ugidfw_check_vp(cred, dvp, MBI_READ));
+	return (ugidfw_check_vp(cred, dvp, MBI_READ, NULL));
 }
 
 int
@@ -186,7 +186,7 @@ ugidfw_vnode_check_readdlink(struct ucred *cred, struct vnode *vp,
     struct label *vplabel)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_READ));
+	return (ugidfw_check_vp(cred, vp, MBI_READ, NULL));
 }
 
 int
@@ -196,10 +196,10 @@ ugidfw_vnode_check_rename_from(struct ucred *cred, struct vnode *dvp,
 {
 	int error;
 
-	error = ugidfw_check_vp(cred, dvp, MBI_WRITE);
+	error = ugidfw_check_vp(cred, dvp, MBI_WRITE, NULL);
 	if (error)
 		return (error);
-	return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 }
 
 int
@@ -209,11 +209,11 @@ ugidfw_vnode_check_rename_to(struct ucred *cred, struct vnode *dvp,
 {
 	int error;
 
-	error = ugidfw_check_vp(cred, dvp, MBI_WRITE);
+	error = ugidfw_check_vp(cred, dvp, MBI_WRITE, NULL);
 	if (error)
 		return (error);
 	if (vp != NULL)
-		error = ugidfw_check_vp(cred, vp, MBI_WRITE);
+		error = ugidfw_check_vp(cred, vp, MBI_WRITE, NULL);
 	return (error);
 }
 
@@ -222,7 +222,7 @@ ugidfw_vnode_check_revoke(struct ucred *cred, struct vnode *vp,
     struct label *vplabel)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -230,7 +230,7 @@ ugidfw_check_setacl_vnode(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, acl_type_t type, struct acl *acl)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -238,7 +238,7 @@ ugidfw_vnode_check_setextattr(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, int attrnamespace, const char *name)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 }
 
 int
@@ -246,7 +246,7 @@ ugidfw_vnode_check_setflags(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, u_long flags)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -254,7 +254,7 @@ ugidfw_vnode_check_setmode(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, mode_t mode)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -262,7 +262,7 @@ ugidfw_vnode_check_setowner(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, uid_t uid, gid_t gid)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -270,7 +270,7 @@ ugidfw_vnode_check_setutimes(struct ucred *cred, struct vnode *vp,
     struct label *vplabel, struct timespec atime, struct timespec utime)
 {
 
-	return (ugidfw_check_vp(cred, vp, MBI_ADMIN));
+	return (ugidfw_check_vp(cred, vp, MBI_ADMIN, NULL));
 }
 
 int
@@ -278,7 +278,7 @@ ugidfw_vnode_check_stat(struct ucred *active_cred,
     struct ucred *file_cred, struct vnode *vp, struct label *vplabel)
 {
 
-	return (ugidfw_check_vp(active_cred, vp, MBI_STAT));
+	return (ugidfw_check_vp(active_cred, vp, MBI_STAT, NULL));
 }
 
 int
@@ -288,8 +288,8 @@ ugidfw_vnode_check_unlink(struct ucred *cred, struct vnode *dvp,
 {
 	int error;
 
-	error = ugidfw_check_vp(cred, dvp, MBI_WRITE);
+	error = ugidfw_check_vp(cred, dvp, MBI_WRITE, NULL);
 	if (error)
 		return (error);
-	return (ugidfw_check_vp(cred, vp, MBI_WRITE));
+	return (ugidfw_check_vp(cred, vp, MBI_WRITE, NULL));
 }
diff --git a/sys/sparc64/sparc64/elf_machdep.c b/sys/sparc64/sparc64/elf_machdep.c
index 4d55717..e0eba33 100644
--- a/sys/sparc64/sparc64/elf_machdep.c
+++ b/sys/sparc64/sparc64/elf_machdep.c
@@ -34,6 +34,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/kernel.h>
 #include <sys/systm.h>
@@ -52,6 +54,10 @@ __FBSDID("$FreeBSD$");
 
 #include <machine/elf.h>
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 #include "linker_if.h"
 
 static struct sysentvec elf64_freebsd_sysvec = {
@@ -87,6 +93,11 @@ static struct sysentvec elf64_freebsd_sysvec = {
 	.sv_fetch_syscall_args = cpu_fetch_syscall_args,
 	.sv_syscallnames = syscallnames,
 	.sv_schedtail	= NULL,
+#ifdef PAX_ASLR
+	.sv_pax_aslr_init = _pax_aslr_init,
+#else
+	.sv_pax_aslr_init = NULL,
+#endif
 };
 
 static Elf64_Brandinfo freebsd_brand_info = {
diff --git a/sys/sys/imgact.h b/sys/sys/imgact.h
index 17cfcc2..15c2c4f 100644
--- a/sys/sys/imgact.h
+++ b/sys/sys/imgact.h
@@ -78,6 +78,7 @@ struct image_params {
 	unsigned long pagesizes;
 	int pagesizeslen;
 	vm_prot_t stack_prot;
+	int pax_flags;
 };
 
 #ifdef _KERNEL
diff --git a/sys/sys/jail.h b/sys/sys/jail.h
index 59d791c..9e6b583 100644
--- a/sys/sys/jail.h
+++ b/sys/sys/jail.h
@@ -184,6 +184,24 @@ struct prison {
 	char		 pr_hostname[MAXHOSTNAMELEN];	/* (p) jail hostname */
 	char		 pr_domainname[MAXHOSTNAMELEN];	/* (p) jail domainname */
 	char		 pr_hostuuid[HOSTUUIDLEN];	/* (p) jail hostuuid */
+    /* Lock only needed for pax_* if pr_pax_set == 0 */
+	int		 pr_pax_set;			/* (p) PaX settings initialized */
+	int		 pr_pax_aslr_status;		/* (p) PaX ASLR enabled */
+	int		 pr_pax_aslr_debug;		/* (p) PaX ASLR debug */
+	int		 pr_pax_aslr_mmap_len;		/* (p) Number of bits randomized with mmap */
+	int		 pr_pax_aslr_stack_len;		/* (p) Number of bits randomized with stack */
+	int		 pr_pax_aslr_exec_len;		/* (p) Number of bits randomized with the execbase */
+	int		 pr_pax_aslr_compat_status;	/* (p) PaX ASLR enabled (compat32) */
+	int		 pr_pax_aslr_compat_mmap_len;	/* (p) Number of bits randomized with mmap (compat32) */
+	int		 pr_pax_aslr_compat_stack_len;	/* (p) Number of bits randomized with stack (compat32) */
+	int		 pr_pax_aslr_compat_exec_len;	/* (p) Number of bits randomized with the execbase (compat32) */
+	int		 pr_pax_segvguard_status;	/* (p) PaX segvguard enabled */
+	int		 pr_pax_segvguard_debug;	/* (p) PaX segvguard debug */
+	int		 pr_pax_segvguard_expiry;	/* (p) Number of seconds to expire an entry */
+	int		 pr_pax_segvguard_suspension;	/* (p) Number of seconds to suspend an application */
+	int		 pr_pax_segvguard_maxcrashes;	/* (p) Maximum number of crashes before suspending application */
+	int		 pr_pax_log_log;		/* (p) XXX */
+	int		 pr_pax_log_ulog;		/* (p) XXX */
 };
 
 struct prison_racct {
diff --git a/sys/sys/kernel.h b/sys/sys/kernel.h
index 3c5258a..aedb52e 100644
--- a/sys/sys/kernel.h
+++ b/sys/sys/kernel.h
@@ -102,6 +102,7 @@ enum sysinit_sub_id {
 	SI_SUB_WITNESS		= 0x1A80000,	/* witness initialization */
 	SI_SUB_MTX_POOL_DYNAMIC	= 0x1AC0000,	/* dynamic mutex pool */
 	SI_SUB_LOCK		= 0x1B00000,	/* various locks */
+	SI_SUB_PAX		= 0x1B50000,	/* pax setup */
 	SI_SUB_EVENTHANDLER	= 0x1C00000,	/* eventhandler init */
 	SI_SUB_VNET_PRELINK	= 0x1E00000,	/* vnet init before modules */
 	SI_SUB_KLD		= 0x2000000,	/* KLD and module setup */
diff --git a/sys/sys/pax.h b/sys/sys/pax.h
new file mode 100644
index 0000000..1ce209a
--- /dev/null
+++ b/sys/sys/pax.h
@@ -0,0 +1,248 @@
+/*-
+ * Copyright (c) 2006 Elad Efrat <elad@NetBSD.org>
+ * Copyright (c) 2013-2014, by Oliver Pinter <oliver.pntr at gmail.com>
+ * Copyright (c) 2014, by Shawn Webb <lattera at gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef	__SYS_PAX_H
+#define	__SYS_PAX_H
+
+struct image_params;
+struct prison;
+struct thread;
+struct vnode;
+struct vmspace;
+struct vm_offset_t;
+
+/*
+ * used in sysctl handler
+ */
+#define PAX_ASLR_DISABLED	0
+#define PAX_ASLR_OPTIN		1
+#define PAX_ASLR_OPTOUT		2
+#define PAX_ASLR_FORCE_ENABLED	3
+
+#define PAX_SEGVGUARD_DISABLED		0
+#define PAX_SEGVGUARD_OPTIN		1
+#define PAX_SEGVGUARD_OPTOUT		2
+#define PAX_SEGVGUARD_FORCE_ENABLED	3
+
+#ifndef PAX_ASLR_DELTA
+#define	PAX_ASLR_DELTA(delta, lsb, len)	\
+	(((delta) & ((1UL << (len)) - 1)) << (lsb))
+#endif /* PAX_ASLR_DELTA */
+
+#ifdef PAX_ASLR
+/*
+ * generic ASLR values
+ *
+ *  	MMAP	| 32 bit | 64 bit |
+ * 	+-------+--------+--------+
+ * 	| MIN	|  8 bit | 16 bit |
+ * 	+-------+--------+--------+
+ * 	| DEF	|  8 bit | 21 bit |
+ * 	+-------+--------+--------+
+ * 	| MAX   | 16 bit | 32 bit |
+ * 	+-------+--------+--------+
+ *
+ *  	STACK	| 32 bit | 64 bit |
+ * 	+-------+--------+--------+
+ * 	| MIN	|  6 bit | 12 bit |
+ * 	+-------+--------+--------+
+ * 	| DEF	|  6 bit | 16 bit |
+ * 	+-------+--------+--------+
+ * 	| MAX   | 10 bit | 21 bit |
+ * 	+-------+--------+--------+
+ *
+ *  	EXEC	| 32 bit | 64 bit |
+ * 	+-------+--------+--------+
+ * 	| MIN	|  6 bit | 12 bit |
+ * 	+-------+--------+--------+
+ * 	| DEF	|  6 bit | 21 bit |
+ * 	+-------+--------+--------+
+ * 	| MAX   | 10 bit | 21 bit |
+ * 	+-------+--------+--------+
+ *
+ */
+#ifndef PAX_ASLR_DELTA_MMAP_LSB
+#define PAX_ASLR_DELTA_MMAP_LSB		PAGE_SHIFT
+#endif /* PAX_ASLR_DELTA_MMAP_LSB */
+
+#ifndef PAX_ASLR_DELTA_MMAP_MIN_LEN
+#define PAX_ASLR_DELTA_MMAP_MIN_LEN	((sizeof(void *) * NBBY) / 4)
+#endif /* PAX_ASLR_DELTA_MMAP_MAX_LEN */
+
+#ifndef PAX_ASLR_DELTA_MMAP_MAX_LEN
+#define PAX_ASLR_DELTA_MMAP_MAX_LEN	((sizeof(void *) * NBBY) / 2)
+#endif /* PAX_ASLR_DELTA_MMAP_MAX_LEN */
+
+#ifndef PAX_ASLR_DELTA_STACK_LSB
+#define PAX_ASLR_DELTA_STACK_LSB	3
+#endif /* PAX_ASLR_DELTA_STACK_LSB */
+
+#ifndef PAX_ASLR_DELTA_STACK_MIN_LEN
+#define PAX_ASLR_DELTA_STACK_MIN_LEN	((sizeof(void *) * NBBY) / 5)
+#endif /* PAX_ASLR_DELTA_STACK_MAX_LEN */
+
+#ifndef PAX_ASLR_DELTA_STACK_MAX_LEN
+#define PAX_ASLR_DELTA_STACK_MAX_LEN	((sizeof(void *) * NBBY) / 3)
+#endif /* PAX_ASLR_DELTA_STACK_MAX_LEN */
+
+#ifndef PAX_ASLR_DELTA_EXEC_LSB
+#define PAX_ASLR_DELTA_EXEC_LSB		PAGE_SHIFT
+#endif /* PAX_ASLR_DELTA_EXEC_LSB */
+
+#ifndef PAX_ASLR_DELTA_EXEC_MIN_LEN
+#define PAX_ASLR_DELTA_EXEC_MIN_LEN	((sizeof(void *) * NBBY) / 5)
+#endif /* PAX_ASLR_DELTA_EXEC_MAX_LEN */
+
+#ifndef PAX_ASLR_DELTA_EXEC_MAX_LEN
+#define PAX_ASLR_DELTA_EXEC_MAX_LEN	((sizeof(void *) * NBBY) / 3)
+#endif /* PAX_ASLR_DELTA_EXEC_MAX_LEN */
+
+/*
+ * ASLR default values for native host
+ */
+#ifdef __amd64__
+#ifndef PAX_ASLR_DELTA_MMAP_DEF_LEN
+#define PAX_ASLR_DELTA_MMAP_DEF_LEN	21
+#endif /* PAX_ASLR_DELTA_MMAP_DEF_LEN */
+#ifndef PAX_ASLR_DELTA_STACK_DEF_LEN
+#define PAX_ASLR_DELTA_STACK_DEF_LEN	16
+#endif /* PAX_ASLR_DELTA_STACK_DEF_LEN */
+#ifndef PAX_ASLR_DELTA_EXEC_DEF_LEN
+#define PAX_ASLR_DELTA_EXEC_DEF_LEN	21
+#endif /* PAX_ASLR_DELTA_EXEC_DEF_LEN */
+#else
+#ifndef PAX_ASLR_DELTA_MMAP_DEF_LEN
+#define PAX_ASLR_DELTA_MMAP_DEF_LEN	PAX_ASLR_DELTA_MMAP_MIN_LEN
+#endif /* PAX_ASLR_DELTA_MMAP_DEF_LEN */
+#ifndef PAX_ASLR_DELTA_STACK_DEF_LEN
+#define PAX_ASLR_DELTA_STACK_DEF_LEN	PAX_ASLR_DELTA_STACK_MIN_LEN
+#endif /* PAX_ASLR_DELTA_STACK_DEF_LEN */
+#ifndef PAX_ASLR_DELTA_EXEC_DEF_LEN
+#define PAX_ASLR_DELTA_EXEC_DEF_LEN	PAX_ASLR_DELTA_EXEC_MIN_LEN
+#endif /* PAX_ASLR_DELTA_EXEC_DEF_LEN */
+#endif /* __amd64__ */
+
+/*
+ * ASLR values for COMPAT_FREEBSD32 and COMPAT_LINUX
+ */
+#ifndef PAX_ASLR_COMPAT_DELTA_MMAP_LSB
+#define PAX_ASLR_COMPAT_DELTA_MMAP_LSB		PAGE_SHIFT
+#endif /* PAX_ASLR_COMPAT_DELTA_MMAP_LSB */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_MMAP_MIN_LEN
+#define PAX_ASLR_COMPAT_DELTA_MMAP_MIN_LEN	((sizeof(int) * NBBY) / 4)
+#endif /* PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN
+#define PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN	((sizeof(int) * NBBY) / 2)
+#endif /* PAX_ASLR_COMPAT_DELTA_MMAP_MAX_LEN */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_STACK_LSB
+#define PAX_ASLR_COMPAT_DELTA_STACK_LSB		3
+#endif /* PAX_ASLR_COMPAT_DELTA_STACK_LSB */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_STACK_MIN_LEN
+#define PAX_ASLR_COMPAT_DELTA_STACK_MIN_LEN	((sizeof(int) * NBBY) / 5)
+#endif /* PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN
+#define PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN	((sizeof(int) * NBBY) / 3)
+#endif /* PAX_ASLR_COMPAT_DELTA_STACK_MAX_LEN */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_EXEC_MIN_LEN
+#define PAX_ASLR_COMPAT_DELTA_EXEC_MIN_LEN	((sizeof(int) * NBBY) / 5)
+#endif /* PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN */
+
+#ifndef PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN
+#define PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN	((sizeof(int) * NBBY) / 3)
+#endif /* PAX_ASLR_COMPAT_DELTA_EXEC_MAX_LEN */
+
+extern int pax_aslr_status;
+extern int pax_aslr_debug;
+
+extern int pax_aslr_mmap_len;
+extern int pax_aslr_stack_len;
+extern int pax_aslr_exec_len;
+#ifdef COMPAT_FREEBSD32
+extern int pax_aslr_compat_status;
+extern int pax_aslr_compat_mmap_len;
+extern int pax_aslr_compat_stack_len;
+extern int pax_aslr_compat_exec_len;
+#endif /* COMPAT_FREEBSD32 */
+#endif /* PAX_ASLR */
+
+#ifdef PAX_SEGVGUARD
+extern int pax_segvguard_status;
+extern int pax_segvguard_debug;
+extern int pax_segvguard_expiry;
+extern int pax_segvguard_suspension;
+extern int pax_segvguard_maxcrashes;
+#endif /* PAX_SEGVGUARD */
+
+extern int pax_log_log;
+extern int pax_log_ulog;
+
+#define ELF_NOTE_TYPE_PAX_TAG   3
+#define PAX_NOTE_MPROTECT   0x01
+#define PAX_NOTE_NOMPROTECT 0x02
+#define PAX_NOTE_GUARD      0x04
+#define PAX_NOTE_NOGUARD    0x08
+#define PAX_NOTE_ASLR       0x10
+#define PAX_NOTE_NOASLR     0x20
+
+#define PAX_SEGVGUARD_EXPIRY        (2 * 60)
+#define PAX_SEGVGUARD_SUSPENSION    (10 * 60)
+#define PAX_SEGVGUARD_MAXCRASHES    5
+#define PAX_SEGVGUARD_NOTCRASHED	0
+#define PAX_SEGVGUARD_CRASHED		1
+
+#define PAX_LOG_LOG		0
+#define PAX_LOG_ULOG		0
+
+void pax_init(void);
+void pax_init_prison(struct prison *pr);
+bool pax_aslr_active(struct thread *td, struct proc *proc);
+void _pax_aslr_init(struct vmspace *vm, struct prison *pr);
+void _pax_aslr_init32(struct vmspace *vm, struct prison *pr);
+void pax_aslr_init(struct thread *td, struct image_params *imgp);
+void pax_aslr_mmap(struct thread *td, vm_offset_t *addr,
+			vm_offset_t orig_addr, int flags);
+void pax_aslr_stack(struct thread *td, uintptr_t *addr);
+struct prison *pax_get_prison(struct thread *td, struct proc *proc);
+void pax_elf(struct image_params *, uint32_t);
+int pax_segvguard(struct thread *, struct vnode *, char *, bool);
+
+void pax_log_aslr(struct prison *pr, const char *func, const char *fmt, ...);
+void pax_ulog_aslr(struct prison *pr, const char *func, const char *fmt, ...);
+void pax_log_segvguard(struct prison *pr, const char *func, const char *fmt, ...);
+void pax_ulog_segvguard(struct prison *pr, const char *func, const char *fmt, ...);
+
+#endif /* __SYS_PAX_H */
diff --git a/sys/sys/proc.h b/sys/sys/proc.h
index fbd064c..558d7bf 100644
--- a/sys/sys/proc.h
+++ b/sys/sys/proc.h
@@ -539,6 +539,7 @@ struct proc {
 	u_int		p_stops;	/* (c) Stop event bitmask. */
 	u_int		p_stype;	/* (c) Stop event type. */
 	char		p_step;		/* (c) Process is stopped. */
+	u_int		p_pax;		/* (b) PaX is enabled to this process */
 	u_char		p_pfsflags;	/* (c) Procfs flags. */
 	struct nlminfo	*p_nlminfo;	/* (?) Only used by/for lockd. */
 	struct kaioinfo	*p_aioinfo;	/* (y) ASYNC I/O info. */
diff --git a/sys/sys/sysent.h b/sys/sys/sysent.h
index c49db41..cfbcdc0 100644
--- a/sys/sys/sysent.h
+++ b/sys/sys/sysent.h
@@ -77,9 +77,11 @@ struct sysent {			/* system call table */
 #define	SY_THR_INCR	0x8
 
 struct image_params;
+struct prison;
 struct __sigset;
 struct syscall_args;
 struct trapframe;
+struct vmspace;
 struct vnode;
 
 struct sysentvec {
@@ -130,6 +132,7 @@ struct sysentvec {
 	uint32_t	sv_timekeep_gen;
 	void		*sv_shared_page_obj;
 	void		(*sv_schedtail)(struct thread *);
+	void		(*sv_pax_aslr_init)(struct vmspace *vm, struct prison *pr);
 };
 
 #define	SV_ILP32	0x000100
diff --git a/sys/vm/vm_map.c b/sys/vm/vm_map.c
index 200e38c..d4123a3 100644
--- a/sys/vm/vm_map.c
+++ b/sys/vm/vm_map.c
@@ -65,6 +65,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_pax.h"
+
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/kernel.h>
@@ -289,6 +291,12 @@ vmspace_alloc(vm_offset_t min, vm_offset_t max, pmap_pinit_t pinit)
 	vm->vm_taddr = 0;
 	vm->vm_daddr = 0;
 	vm->vm_maxsaddr = 0;
+#ifdef PAX_ASLR
+	vm->vm_aslr_delta_mmap = 0;
+	vm->vm_aslr_delta_stack = 0;
+	vm->vm_aslr_delta_exec = 0;
+#endif
+
 	return (vm);
 }
 
diff --git a/sys/vm/vm_map.h b/sys/vm/vm_map.h
index 850bf25..4524c9f 100644
--- a/sys/vm/vm_map.h
+++ b/sys/vm/vm_map.h
@@ -241,6 +241,9 @@ struct vmspace {
 	caddr_t vm_taddr;	/* (c) user virtual address of text */
 	caddr_t vm_daddr;	/* (c) user virtual address of data */
 	caddr_t vm_maxsaddr;	/* user VA at max stack growth */
+	vm_size_t vm_aslr_delta_mmap;	/* mmap() random delta for ASLR */
+	vm_size_t vm_aslr_delta_stack;	/* stack random delta for ASLR */
+	vm_size_t vm_aslr_delta_exec;	/* exec base random delta for ASLR */
 	volatile int vm_refcnt;	/* number of references */
 	/*
 	 * Keep the PMAP last, so that CPU-specific variations of that
diff --git a/sys/vm/vm_mmap.c b/sys/vm/vm_mmap.c
index 60aa621..12c8448 100644
--- a/sys/vm/vm_mmap.c
+++ b/sys/vm/vm_mmap.c
@@ -45,6 +45,7 @@ __FBSDID("$FreeBSD$");
 
 #include "opt_compat.h"
 #include "opt_hwpmc_hooks.h"
+#include "opt_pax.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -91,6 +92,10 @@ __FBSDID("$FreeBSD$");
 #include <sys/pmckern.h>
 #endif
 
+#ifdef PAX_ASLR
+#include <sys/pax.h>
+#endif
+
 int old_mlock = 0;
 SYSCTL_INT(_vm, OID_AUTO, old_mlock, CTLFLAG_RW | CTLFLAG_TUN, &old_mlock, 0,
     "Do not apply RLIMIT_MEMLOCK on mlockall");
@@ -203,6 +208,9 @@ sys_mmap(td, uap)
 	struct file *fp;
 	struct vnode *vp;
 	vm_offset_t addr;
+#ifdef PAX_ASLR
+	vm_offset_t orig_addr;
+#endif
 	vm_size_t size, pageoff;
 	vm_prot_t cap_maxprot, prot, maxprot;
 	void *handle;
@@ -213,6 +221,9 @@ sys_mmap(td, uap)
 	cap_rights_t rights;
 
 	addr = (vm_offset_t) uap->addr;
+#ifdef PAX_ASLR
+	orig_addr = addr;
+#endif
 	size = uap->len;
 	prot = uap->prot & VM_PROT_ALL;
 	flags = uap->flags;
@@ -309,9 +320,10 @@ sys_mmap(td, uap)
 		if (addr == 0 ||
 		    (addr >= round_page((vm_offset_t)vms->vm_taddr) &&
 		    addr < round_page((vm_offset_t)vms->vm_daddr +
-		    lim_max(td->td_proc, RLIMIT_DATA))))
+		    lim_max(td->td_proc, RLIMIT_DATA)))) {
 			addr = round_page((vm_offset_t)vms->vm_daddr +
 			    lim_max(td->td_proc, RLIMIT_DATA));
+		}
 		PROC_UNLOCK(td->td_proc);
 	}
 	if (flags & MAP_ANON) {
@@ -414,6 +426,9 @@ sys_mmap(td, uap)
 map:
 	td->td_fpop = fp;
 	maxprot &= cap_maxprot;
+#ifdef PAX_ASLR
+	pax_aslr_mmap(td, &addr, orig_addr, flags);
+#endif
 	error = vm_mmap(&vms->vm_map, &addr, size, prot, maxprot,
 	    flags, handle_type, handle, pos);
 	td->td_fpop = NULL;
diff --git a/tools/build/options/WITHOUT_PIE b/tools/build/options/WITHOUT_PIE
new file mode 100644
index 0000000..82019ce
--- /dev/null
+++ b/tools/build/options/WITHOUT_PIE
@@ -0,0 +1 @@
+Enable building of Position-Independent Executables (PIEs).
diff --git a/usr.bin/clang/clang-tblgen/Makefile b/usr.bin/clang/clang-tblgen/Makefile
index 0f64ad3..d9758e5 100644
--- a/usr.bin/clang/clang-tblgen/Makefile
+++ b/usr.bin/clang/clang-tblgen/Makefile
@@ -19,4 +19,6 @@ SRCS=	ClangASTNodesEmitter.cpp \
 LIBDEPS=llvmtablegen \
 	llvmsupport
 
+NO_PIE=yes
+
 .include "../clang.prog.mk"
diff --git a/usr.bin/clang/clang.prog.mk b/usr.bin/clang/clang.prog.mk
index 4cd1052..5f8f7a9 100644
--- a/usr.bin/clang/clang.prog.mk
+++ b/usr.bin/clang/clang.prog.mk
@@ -1,5 +1,7 @@
 # $FreeBSD$
 
+NO_PIE=	yes
+
 LLVM_SRCS= ${.CURDIR}/../../../contrib/llvm
 
 .include "../../lib/clang/clang.build.mk"
diff --git a/usr.bin/clang/tblgen/Makefile b/usr.bin/clang/tblgen/Makefile
index f06150e..652b827 100644
--- a/usr.bin/clang/tblgen/Makefile
+++ b/usr.bin/clang/tblgen/Makefile
@@ -42,4 +42,6 @@ SRCS=	AsmMatcherEmitter.cpp \
 LIBDEPS=llvmtablegen \
 	llvmsupport
 
+NO_PIE=yes
+
 .include "../clang.prog.mk"
diff --git a/usr.bin/compile_et/Makefile b/usr.bin/compile_et/Makefile
index d7177b2..271fcf0 100644
--- a/usr.bin/compile_et/Makefile
+++ b/usr.bin/compile_et/Makefile
@@ -12,4 +12,6 @@ CFLAGS+=-I. -I${.CURDIR}/../../contrib/com_err
 
 WARNS?=	0
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/mandoc/Makefile b/usr.bin/mandoc/Makefile
index ed88f4e..69ca10d 100644
--- a/usr.bin/mandoc/Makefile
+++ b/usr.bin/mandoc/Makefile
@@ -19,4 +19,6 @@ CFLAGS+= -DHAVE_CONFIG_H
 DPADD=	${LIBMANDOC}
 LDADD=	${LIBMANDOC}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svn/Makefile b/usr.bin/svn/svn/Makefile
index dfa2e38..103284f 100644
--- a/usr.bin/svn/svn/Makefile
+++ b/usr.bin/svn/svn/Makefile
@@ -8,6 +8,8 @@ MAN=
 
 PROG=	svn${SVNLITE}
 
+NO_PIE=yes
+
 SRCS=	add-cmd.c blame-cmd.c cat-cmd.c changelist-cmd.c checkout-cmd.c \
 	cl-conflicts.c cleanup-cmd.c commit-cmd.c conflict-callbacks.c \
 	copy-cmd.c delete-cmd.c deprecated.c diff-cmd.c export-cmd.c \
diff --git a/usr.bin/svn/svnadmin/Makefile b/usr.bin/svn/svnadmin/Makefile
index 3220cde..1240e57 100644
--- a/usr.bin/svn/svnadmin/Makefile
+++ b/usr.bin/svn/svnadmin/Makefile
@@ -34,4 +34,6 @@ DPADD=	${LIBSVN_REPOS} ${LIBSVN_FS} ${LIBSVN_FS_FS} ${LIBSVN_FS_UTIL} \
 	${LIBSVN_DELTA} ${LIBSVN_SUBR} ${LIBAPR_UTIL} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svndumpfilter/Makefile b/usr.bin/svn/svndumpfilter/Makefile
index 864f376..82e0e85 100644
--- a/usr.bin/svn/svndumpfilter/Makefile
+++ b/usr.bin/svn/svndumpfilter/Makefile
@@ -34,4 +34,6 @@ DPADD=	${LIBSVN_REPOS} ${LIBSVN_FS} ${LIBSVN_FS_FS} ${LIBSVN_FS_UTIL} \
 	${LIBSVN_DELTA} ${LIBSVN_SUBR} ${LIBAPR_UTIL} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnlook/Makefile b/usr.bin/svn/svnlook/Makefile
index 3d8b1a0..d19177a 100644
--- a/usr.bin/svn/svnlook/Makefile
+++ b/usr.bin/svn/svnlook/Makefile
@@ -35,4 +35,6 @@ DPADD=	${LIBSVN_REPOS} ${LIBSVN_FS} ${LIBSVN_FS_FS} ${LIBSVN_FS_UTIL} \
 	${LIBSVN_DELTA} ${LIBSVN_DIFF} ${LIBSVN_SUBR} ${LIBAPR_UTIL} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnmucc/Makefile b/usr.bin/svn/svnmucc/Makefile
index 23a98e3..f824aa2 100644
--- a/usr.bin/svn/svnmucc/Makefile
+++ b/usr.bin/svn/svnmucc/Makefile
@@ -42,4 +42,6 @@ DPADD=	${LIBSVN_CLIENT} ${LIBSVN_RA} ${LIBSVN_RA_LOCAL} ${LIBSVN_RA_SVN} \
 	${LIBAPR_UTIL} ${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} \
 	${LIBCRYPT} ${LIBMAGIC} ${LIBCRYPTO} ${LIBSSL} ${LIBPTHREAD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnrdump/Makefile b/usr.bin/svn/svnrdump/Makefile
index afeae00..5f1d915 100644
--- a/usr.bin/svn/svnrdump/Makefile
+++ b/usr.bin/svn/svnrdump/Makefile
@@ -45,4 +45,6 @@ DPADD=	${LIBSVN_CLIENT} ${LIBSVN_WC} ${LIBSVN_RA} ${LIBSVN_RA_LOCAL} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT} ${LIBMAGIC} \
 	${LIBCRYPTO} ${LIBSSL} ${LIBPTHREAD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnserve/Makefile b/usr.bin/svn/svnserve/Makefile
index f1fa314..e4b2686 100644
--- a/usr.bin/svn/svnserve/Makefile
+++ b/usr.bin/svn/svnserve/Makefile
@@ -41,4 +41,6 @@ DPADD=	${LIBSVN_RA} ${LIBSVN_RA_LOCAL} ${LIBSVN_RA_SVN} ${LIBSVN_RA_SERF} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT} ${LIBMAGIC} \
 	${LIBCRYPTO} ${LIBSSL} ${LIBPTHREAD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnsync/Makefile b/usr.bin/svn/svnsync/Makefile
index a8cd380..fa53b96 100644
--- a/usr.bin/svn/svnsync/Makefile
+++ b/usr.bin/svn/svnsync/Makefile
@@ -41,4 +41,6 @@ DPADD=	${LIBSVN_RA} ${LIBSVN_RA_LOCAL} ${LIBSVN_RA_SVN} ${LIBSVN_RA_SERF} \
 	${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} ${LIBZ} ${LIBCRYPT} ${LIBMAGIC} \
 	${LIBCRYPTO} ${LIBSSL} ${LIBPTHREAD}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/svn/svnversion/Makefile b/usr.bin/svn/svnversion/Makefile
index ca28ec3..7fcc494 100644
--- a/usr.bin/svn/svnversion/Makefile
+++ b/usr.bin/svn/svnversion/Makefile
@@ -32,4 +32,6 @@ DPADD=	${LIBSVN_WC} ${LIBSVN_DELTA} ${LIBSVN_DIFF} ${LIBSVN_SUBR} \
 	${LIBSERF} ${LIBAPR_UTIL} ${LIBBSDXML} ${LIBAPR} ${LIBSQLITE} \
 	${LIBZ} ${LIBCRYPT}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.bin/telnet/Makefile b/usr.bin/telnet/Makefile
index d47bb91..e5eaa4e 100644
--- a/usr.bin/telnet/Makefile
+++ b/usr.bin/telnet/Makefile
@@ -13,6 +13,8 @@ SRCS=		commands.c main.c network.c ring.c sys_bsd.c \
 CFLAGS+=	-DKLUDGELINEMODE -DUSE_TERMIO -DENV_HACK -DOPIE \
 		-I${TELNETDIR} -I${TELNETDIR}/libtelnet/
 
+NO_PIE=yes
+
 .if ${MK_INET6_SUPPORT} != "no"
 CFLAGS+=	-DINET6
 .endif
diff --git a/usr.bin/vacation/Makefile b/usr.bin/vacation/Makefile
index 056f576..891adba 100644
--- a/usr.bin/vacation/Makefile
+++ b/usr.bin/vacation/Makefile
@@ -32,6 +32,8 @@ DPADD+=${SENDMAIL_DPADD}
 LDADD+=${SENDMAIL_LDADD}
 LDFLAGS+=${SENDMAIL_LDFLAGS}
 
+NO_PIE=yes
+
 sm_os.h:
 	ln -sf ${SENDMAIL_DIR}/include/sm/os/sm_os_freebsd.h sm_os.h
 
diff --git a/usr.sbin/amd/amd/Makefile b/usr.sbin/amd/amd/Makefile
index 1fc41bf..7faf66c 100644
--- a/usr.sbin/amd/amd/Makefile
+++ b/usr.sbin/amd/amd/Makefile
@@ -24,6 +24,8 @@ SRCS+=	ops_nullfs.c ops_pcfs.c ops_tfs.c ops_ufs.c ops_umapfs.c
 SRCS+=	ops_unionfs.c opts.c readdir.c restart.c rpc_fwd.c sched.c
 SRCS+=	srvr_amfs_auto.c srvr_nfs.c
 
+NO_PIE=yes
+
 CFLAGS+= -I${.CURDIR}/../../../contrib/amd/amd \
 	 -I${DESTDIR}/usr/include/rpcsvc
 
diff --git a/usr.sbin/amd/amq/Makefile b/usr.sbin/amd/amq/Makefile
index 74fc749..71b01e8 100644
--- a/usr.sbin/amd/amq/Makefile
+++ b/usr.sbin/amd/amq/Makefile
@@ -17,4 +17,6 @@ CFLAGS+= -I${.CURDIR}/../../../contrib/amd/amq
 DPADD=	${LIBAMU}
 LDADD=	${LIBAMU}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/amd/fixmount/Makefile b/usr.sbin/amd/fixmount/Makefile
index 7f96a45..041d83a 100644
--- a/usr.sbin/amd/fixmount/Makefile
+++ b/usr.sbin/amd/fixmount/Makefile
@@ -18,4 +18,6 @@ SRCS+=	checkmount_bsd44.c
 DPADD=	${LIBAMU} ${LIBRPCSVC}
 LDADD=	${LIBAMU} -lrpcsvc
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/amd/fsinfo/Makefile b/usr.sbin/amd/fsinfo/Makefile
index 1695a46..f301171 100644
--- a/usr.sbin/amd/fsinfo/Makefile
+++ b/usr.sbin/amd/fsinfo/Makefile
@@ -13,6 +13,8 @@ SRCS=	fsi_gram.y fsi_lex.l
 SRCS+=	fsi_analyze.c fsi_dict.c fsi_util.c fsinfo.c wr_atab.c 
 SRCS+=	wr_bparam.c wr_dumpset.c wr_exportfs.c wr_fstab.c
 
+NO_PIE=yes
+
 CFLAGS+= -I${.CURDIR}/../../../contrib/amd/fsinfo
 
 DPADD=	${LIBAMU}
diff --git a/usr.sbin/amd/hlfsd/Makefile b/usr.sbin/amd/hlfsd/Makefile
index 5b863dd..5c3a0ad 100644
--- a/usr.sbin/amd/hlfsd/Makefile
+++ b/usr.sbin/amd/hlfsd/Makefile
@@ -16,4 +16,6 @@ CFLAGS+= -I${.CURDIR}/../../../contrib/amd/hlfsd
 DPADD=	${LIBAMU}
 LDADD=	${LIBAMU}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/amd/mk-amd-map/Makefile b/usr.sbin/amd/mk-amd-map/Makefile
index 57fd6a5..90108e0 100644
--- a/usr.sbin/amd/mk-amd-map/Makefile
+++ b/usr.sbin/amd/mk-amd-map/Makefile
@@ -13,4 +13,6 @@ MAN=	mk-amd-map.8
 DPADD=	${LIBAMU}
 LDADD=	${LIBAMU}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/amd/pawd/Makefile b/usr.sbin/amd/pawd/Makefile
index c6bb1cc..221abd3 100644
--- a/usr.sbin/amd/pawd/Makefile
+++ b/usr.sbin/amd/pawd/Makefile
@@ -17,4 +17,6 @@ CFLAGS+= -I${.CURDIR}/../../../contrib/amd/amq
 DPADD=	${LIBAMU}
 LDADD=	${LIBAMU}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/amd/wire-test/Makefile b/usr.sbin/amd/wire-test/Makefile
index a07e690..8ea6969 100644
--- a/usr.sbin/amd/wire-test/Makefile
+++ b/usr.sbin/amd/wire-test/Makefile
@@ -13,4 +13,6 @@ MAN=	wire-test.8
 DPADD=	${LIBAMU}
 LDADD=	${LIBAMU}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/btxld/Makefile b/usr.sbin/btxld/Makefile
index 32cf99d..9cdc581 100644
--- a/usr.sbin/btxld/Makefile
+++ b/usr.sbin/btxld/Makefile
@@ -4,4 +4,6 @@ PROG=	btxld
 MAN=	btxld.8
 SRCS=	btxld.c elfh.c
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/cron/cron/Makefile b/usr.sbin/cron/cron/Makefile
index d9a1d24..d2eb5e7 100644
--- a/usr.sbin/cron/cron/Makefile
+++ b/usr.sbin/cron/cron/Makefile
@@ -11,4 +11,6 @@ LDADD=	${LIBCRON} ${MINUSLPAM} -lutil
 
 WARNS?=	2
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/cron/crontab/Makefile b/usr.sbin/cron/crontab/Makefile
index 829128e..8bb69bd 100644
--- a/usr.sbin/cron/crontab/Makefile
+++ b/usr.sbin/cron/crontab/Makefile
@@ -15,4 +15,6 @@ CFLAGS+= -I${.CURDIR}/../cron
 DPADD=	${LIBCRON} ${LIBMD} ${LIBUTIL}
 LDADD=	${LIBCRON} -lmd -lutil
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/crunch/crunchgen/Makefile b/usr.sbin/crunch/crunchgen/Makefile
index 8d0a78b..8fa0cd8 100644
--- a/usr.sbin/crunch/crunchgen/Makefile
+++ b/usr.sbin/crunch/crunchgen/Makefile
@@ -4,6 +4,8 @@ PROG=	crunchgen
 SRCS=	crunchgen.c crunched_skel.c
 CLEANFILES+= crunched_skel.c
 
+NO_PIE=yes
+
 crunched_skel.c: crunched_main.c
 	sh -e ${.CURDIR}/mkskel.sh ${.CURDIR}/crunched_main.c >crunched_skel.c
 
diff --git a/usr.sbin/crunch/crunchide/Makefile b/usr.sbin/crunch/crunchide/Makefile
index 2a6c500..985aa95 100644
--- a/usr.sbin/crunch/crunchide/Makefile
+++ b/usr.sbin/crunch/crunchide/Makefile
@@ -3,6 +3,8 @@
 PROG=   crunchide
 SRCS=	crunchide.c
 
+NO_PIE=yes
+
 TARGET_ARCH?=	${MACHINE_ARCH}
 
 .if ${TARGET_ARCH} == i386 && ${MACHINE_ARCH} == i386
diff --git a/usr.sbin/editmap/Makefile b/usr.sbin/editmap/Makefile
index 92d8392..78578dc 100644
--- a/usr.sbin/editmap/Makefile
+++ b/usr.sbin/editmap/Makefile
@@ -33,6 +33,8 @@ DPADD+=${SENDMAIL_DPADD}
 LDADD+=${SENDMAIL_LDADD}
 LDFLAGS+=${SENDMAIL_LDFLAGS}
 
+NO_PIE=yes
+
 sm_os.h:
 	ln -sf ${SENDMAIL_DIR}/include/sm/os/sm_os_freebsd.h sm_os.h
 
diff --git a/usr.sbin/fifolog/fifolog_create/Makefile b/usr.sbin/fifolog/fifolog_create/Makefile
index 8b59b25..c9c9d3d 100644
--- a/usr.sbin/fifolog/fifolog_create/Makefile
+++ b/usr.sbin/fifolog/fifolog_create/Makefile
@@ -12,6 +12,8 @@ MLINKS=	fifolog.1 fifolog_create.1 \
 	fifolog.1 fifolog_reader.1 \
 	fifolog.1 fifolog_writer.1
 
+NO_PIE=yes
+
 regress:
 	rm -f /tmp/fifolog.?
 	./${PROG} /tmp/fifolog.0
diff --git a/usr.sbin/fifolog/fifolog_reader/Makefile b/usr.sbin/fifolog/fifolog_reader/Makefile
index c88f10e..6b5fb77 100644
--- a/usr.sbin/fifolog/fifolog_reader/Makefile
+++ b/usr.sbin/fifolog/fifolog_reader/Makefile
@@ -9,6 +9,8 @@ MAN=
 DPADD=	${LIBFIFOLOG} ${LIBUTIL} ${LIBZ}
 LDADD=	${LIBFIFOLOG} -lutil -lz
 
+NO_PIE=yes
+
 regress:
 	./${PROG} /tmp/fifolog.0
 	./${PROG} -t /tmp/fifolog.0
diff --git a/usr.sbin/fifolog/fifolog_writer/Makefile b/usr.sbin/fifolog/fifolog_writer/Makefile
index 9d802c7..8f04079 100644
--- a/usr.sbin/fifolog/fifolog_writer/Makefile
+++ b/usr.sbin/fifolog/fifolog_writer/Makefile
@@ -9,6 +9,8 @@ MAN=
 DPADD=	${LIBFIFOLOG} ${LIBUTIL} ${LIBZ}
 LDADD=	${LIBFIFOLOG} -lutil -lz
 
+NO_PIE=yes
+
 regress:
 	date | ./${PROG} -z 0 /tmp/fifolog.0
 	lptest 65 | ./${PROG} -z 9 /tmp/fifolog.1
diff --git a/usr.sbin/ftp-proxy/ftp-proxy/Makefile b/usr.sbin/ftp-proxy/ftp-proxy/Makefile
index de49888..c0eae1d 100644
--- a/usr.sbin/ftp-proxy/ftp-proxy/Makefile
+++ b/usr.sbin/ftp-proxy/ftp-proxy/Makefile
@@ -14,4 +14,6 @@ DPADD+= ${LIBEVENT}
 
 WARNS?=	3
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/chkprintcap/Makefile b/usr.sbin/lpr/chkprintcap/Makefile
index ffffffb..b60ac8d 100644
--- a/usr.sbin/lpr/chkprintcap/Makefile
+++ b/usr.sbin/lpr/chkprintcap/Makefile
@@ -11,4 +11,6 @@ CFLAGS+= -I${.CURDIR}/../common_source
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/lpc/Makefile b/usr.sbin/lpr/lpc/Makefile
index 35fa52a..b9436a0 100644
--- a/usr.sbin/lpr/lpc/Makefile
+++ b/usr.sbin/lpr/lpc/Makefile
@@ -16,4 +16,6 @@ WARNS?=	0
 DPADD=	${LIBLPR} ${LIBEDIT} ${LIBTERMCAP}
 LDADD=	${LIBLPR} -ledit -ltermcap
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/lpd/Makefile b/usr.sbin/lpr/lpd/Makefile
index 0d7d93e..f611076 100644
--- a/usr.sbin/lpr/lpd/Makefile
+++ b/usr.sbin/lpr/lpd/Makefile
@@ -12,4 +12,6 @@ WARNS?=	1
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/lpq/Makefile b/usr.sbin/lpr/lpq/Makefile
index 4df437e..f821828 100644
--- a/usr.sbin/lpr/lpq/Makefile
+++ b/usr.sbin/lpr/lpq/Makefile
@@ -13,4 +13,6 @@ CFLAGS+= -I${.CURDIR}/../common_source
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/lpr/Makefile b/usr.sbin/lpr/lpr/Makefile
index 1894b00..a10658c 100644
--- a/usr.sbin/lpr/lpr/Makefile
+++ b/usr.sbin/lpr/lpr/Makefile
@@ -18,4 +18,6 @@ WARNS?=	2
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/lprm/Makefile b/usr.sbin/lpr/lprm/Makefile
index 44bc93a..802a97c 100644
--- a/usr.sbin/lpr/lprm/Makefile
+++ b/usr.sbin/lpr/lprm/Makefile
@@ -15,4 +15,6 @@ CFLAGS+= -I${.CURDIR}/../common_source
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/lpr/pac/Makefile b/usr.sbin/lpr/pac/Makefile
index bd895a7..ff2c75c 100644
--- a/usr.sbin/lpr/pac/Makefile
+++ b/usr.sbin/lpr/pac/Makefile
@@ -11,4 +11,6 @@ CFLAGS+= -I${.CURDIR}/../common_source
 DPADD=	${LIBLPR}
 LDADD=	${LIBLPR}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/mailstats/Makefile b/usr.sbin/mailstats/Makefile
index bd72fc6..2b0a7ba 100644
--- a/usr.sbin/mailstats/Makefile
+++ b/usr.sbin/mailstats/Makefile
@@ -31,6 +31,8 @@ DPADD+=	${SENDMAIL_DPADD}
 LDADD+=	${SENDMAIL_LDADD}
 LDFLAGS+= ${SENDMAIL_LDFLAGS}
 
+NO_PIE=yes
+
 sm_os.h:
 	ln -sf ${SENDMAIL_DIR}/include/sm/os/sm_os_freebsd.h sm_os.h
 
diff --git a/usr.sbin/makefs/Makefile b/usr.sbin/makefs/Makefile
index 6253148..bc1e536 100644
--- a/usr.sbin/makefs/Makefile
+++ b/usr.sbin/makefs/Makefile
@@ -38,4 +38,6 @@ LDADD+=		${LIBNETBSD}
 DPADD+=  ${LIBSBUF} ${LIBUTIL}
 LDADD+=  -lsbuf -lutil
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/makemap/Makefile b/usr.sbin/makemap/Makefile
index 80cafcb..dd0b6ad 100644
--- a/usr.sbin/makemap/Makefile
+++ b/usr.sbin/makemap/Makefile
@@ -34,6 +34,8 @@ DPADD+=${SENDMAIL_DPADD}
 LDADD+=${SENDMAIL_LDADD}
 LDFLAGS+=${SENDMAIL_LDFLAGS}
 
+NO_PIE=yes
+
 sm_os.h:
 	ln -sf ${SENDMAIL_DIR}/include/sm/os/sm_os_freebsd.h sm_os.h
 
diff --git a/usr.sbin/nmtree/Makefile b/usr.sbin/nmtree/Makefile
index 9d24c0c..623e91f 100644
--- a/usr.sbin/nmtree/Makefile
+++ b/usr.sbin/nmtree/Makefile
@@ -23,4 +23,6 @@ LDADD+=		${LIBNETBSD}
 LINKS=		${BINDIR}/mtree ${BINDIR}/nmtree
 MLINKS=		mtree.8 nmtree.8
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/ntp/ntp-keygen/Makefile b/usr.sbin/ntp/ntp-keygen/Makefile
index fea148c..968e96e 100644
--- a/usr.sbin/ntp/ntp-keygen/Makefile
+++ b/usr.sbin/ntp/ntp-keygen/Makefile
@@ -21,4 +21,6 @@ DPADD+=	${LIBMD} ${LIBCRYPTO}
 LDADD+=	-lmd -lcrypto
 .endif
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/ntp/ntpd/Makefile b/usr.sbin/ntp/ntpd/Makefile
index 53f537f..9f74523 100644
--- a/usr.sbin/ntp/ntpd/Makefile
+++ b/usr.sbin/ntp/ntpd/Makefile
@@ -4,6 +4,8 @@ MAN=
 
 .include <src.opts.mk>
 
+NO_PIE=yes
+
 .PATH: ${.CURDIR}/../../../contrib/ntp/ntpd
 
 PROG=	ntpd
diff --git a/usr.sbin/ntp/ntpdate/Makefile b/usr.sbin/ntp/ntpdate/Makefile
index f55ec92..9e8f4dd 100644
--- a/usr.sbin/ntp/ntpdate/Makefile
+++ b/usr.sbin/ntp/ntpdate/Makefile
@@ -13,6 +13,8 @@ LDADD=	${LIBNTP} -lm -lmd -lrt
 
 CLEANFILES+= .version version.c
 
+NO_PIE=yes
+
 version.c: 
 	sh -e ${.CURDIR}/../scripts/mkver ntpdate
 
diff --git a/usr.sbin/ntp/ntpdc/Makefile b/usr.sbin/ntp/ntpdc/Makefile
index 81d2671..18ece79 100644
--- a/usr.sbin/ntp/ntpdc/Makefile
+++ b/usr.sbin/ntp/ntpdc/Makefile
@@ -22,6 +22,8 @@ CFLAGS+=	-DHAVE_LIBEDIT -DHAVE_READLINE_READLINE_H \
 
 CLEANFILES+= .version version.c
 
+NO_PIE=yes
+
 version.c:
 	sh -e ${.CURDIR}/../scripts/mkver ntpdc
 
diff --git a/usr.sbin/ntp/ntpq/Makefile b/usr.sbin/ntp/ntpq/Makefile
index eb42973..1e50687 100644
--- a/usr.sbin/ntp/ntpq/Makefile
+++ b/usr.sbin/ntp/ntpq/Makefile
@@ -24,6 +24,8 @@ CFLAGS+=	-DHAVE_LIBEDIT -DHAVE_READLINE_READLINE_H \
 
 CLEANFILES+= .version version.c
 
+NO_PIE=yes
+
 version.c:
 	sh -e ${.CURDIR}/../scripts/mkver ntpq
 
diff --git a/usr.sbin/ntp/ntptime/Makefile b/usr.sbin/ntp/ntptime/Makefile
index d3bf7a7..21a6a68 100644
--- a/usr.sbin/ntp/ntptime/Makefile
+++ b/usr.sbin/ntp/ntptime/Makefile
@@ -10,4 +10,6 @@ CFLAGS+= -I${.CURDIR}/../../../contrib/ntp/include -I${.CURDIR}/../
 DPADD=	${LIBNTP}
 LDADD=	${LIBNTP}
 
+NO_PIE=yes
+
 .include <bsd.prog.mk>
diff --git a/usr.sbin/praliases/Makefile b/usr.sbin/praliases/Makefile
index 120028d..6d51f40 100644
--- a/usr.sbin/praliases/Makefile
+++ b/usr.sbin/praliases/Makefile
@@ -34,6 +34,8 @@ LDFLAGS+=${SENDMAIL_LDFLAGS}
 DPADD+=	${SENDMAIL_DPADD}
 LDADD+=	${SENDMAIL_LDADD}
 
+NO_PIE=yes
+
 sm_os.h:
 	ln -sf ${SENDMAIL_DIR}/include/sm/os/sm_os_freebsd.h sm_os.h
 
diff --git a/usr.sbin/sendmail/Makefile b/usr.sbin/sendmail/Makefile
index f8a910b..9b3fc99 100644
--- a/usr.sbin/sendmail/Makefile
+++ b/usr.sbin/sendmail/Makefile
@@ -7,6 +7,8 @@ SENDMAIL_DIR=${.CURDIR}/../../contrib/sendmail
 SMDIR=	${SENDMAIL_DIR}/src
 .PATH: ${SMDIR}
 
+NO_PIE=yes
+
 BINDIR=	/usr/libexec/sendmail
 
 PROG=	sendmail
diff --git a/usr.sbin/ugidfw/ugidfw.c b/usr.sbin/ugidfw/ugidfw.c
index 977922a..515df16 100644
--- a/usr.sbin/ugidfw/ugidfw.c
+++ b/usr.sbin/ugidfw/ugidfw.c
@@ -46,6 +46,8 @@ __FBSDID("$FreeBSD$");
 #include <string.h>
 #include <ugidfw.h>
 
+#define UGIDFW_BUFSIZ (BUFSIZ*2)
+
 void add_rule(int argc, char *argv[]);
 void list_rules(void);
 void remove_rule(int argc, char *argv[]);
@@ -71,22 +73,22 @@ usage(void)
 void
 add_rule(int argc, char *argv[])
 {
-	char errstr[BUFSIZ], charstr[BUFSIZ];
+	char errstr[UGIDFW_BUFSIZ], charstr[UGIDFW_BUFSIZ];
 	struct mac_bsdextended_rule rule;
 	int error, rulenum;
 
-	error = bsde_parse_rule(argc, argv, &rule, BUFSIZ, errstr);
+	error = bsde_parse_rule(argc, argv, &rule, UGIDFW_BUFSIZ, errstr);
 	if (error) {
 		warnx("%s", errstr);
 		return;
 	}
 
-	error = bsde_add_rule(&rulenum, &rule, BUFSIZ, errstr);
+	error = bsde_add_rule(&rulenum, &rule, UGIDFW_BUFSIZ, errstr);
 	if (error) {
 		warnx("%s", errstr);
 		return;
 	}
-	if (bsde_rule_to_string(&rule, charstr, BUFSIZ) == -1)
+	if (bsde_rule_to_string(&rule, charstr, UGIDFW_BUFSIZ) == -1)
 		warnx("Added rule, but unable to print string.");
 	else
 		printf("%d %s\n", rulenum, charstr);
@@ -95,25 +97,25 @@ add_rule(int argc, char *argv[])
 void
 list_rules(void)
 {
-	char errstr[BUFSIZ], charstr[BUFSIZ];
+	char errstr[UGIDFW_BUFSIZ], charstr[UGIDFW_BUFSIZ];
 	struct mac_bsdextended_rule rule;
 	int error, i, rule_count, rule_slots;
 
-	rule_slots = bsde_get_rule_slots(BUFSIZ, errstr);
+	rule_slots = bsde_get_rule_slots(UGIDFW_BUFSIZ, errstr);
 	if (rule_slots == -1) {
 		warnx("unable to get rule slots; mac_bsdextended.ko "
 		    "may not be loaded");
 		errx(1, "bsde_get_rule_slots: %s", errstr);
 	}
 
-	rule_count = bsde_get_rule_count(BUFSIZ, errstr);
+	rule_count = bsde_get_rule_count(UGIDFW_BUFSIZ, errstr);
 	if (rule_count == -1)
 		errx(1, "bsde_get_rule_count: %s", errstr);
 
 	printf("%d slots, %d rules\n", rule_slots, rule_count);
 
 	for (i = 0; i < rule_slots; i++) {
-		error = bsde_get_rule(i, &rule, BUFSIZ, errstr);
+		error = bsde_get_rule(i, &rule, UGIDFW_BUFSIZ, errstr);
 		switch (error) {
 		case -2:
 			continue;
@@ -124,7 +126,7 @@ list_rules(void)
 			break;
 		}
 
-		if (bsde_rule_to_string(&rule, charstr, BUFSIZ) == -1)
+		if (bsde_rule_to_string(&rule, charstr, UGIDFW_BUFSIZ) == -1)
 			warnx("unable to translate rule %d to string", i);
 		else
 			printf("%d %s\n", i, charstr);
@@ -134,7 +136,7 @@ list_rules(void)
 void
 set_rule(int argc, char *argv[])
 {
-	char errstr[BUFSIZ];
+	char errstr[UGIDFW_BUFSIZ];
 	struct mac_bsdextended_rule rule;
 	long value;
 	int error, rulenum;
@@ -152,13 +154,13 @@ set_rule(int argc, char *argv[])
 
 	rulenum = value;
 
-	error = bsde_parse_rule(argc - 1, argv + 1, &rule, BUFSIZ, errstr);
+	error = bsde_parse_rule(argc - 1, argv + 1, &rule, UGIDFW_BUFSIZ, errstr);
 	if (error) {
 		warnx("%s", errstr);
 		return;
 	}
 
-	error = bsde_set_rule(rulenum, &rule, BUFSIZ, errstr);
+	error = bsde_set_rule(rulenum, &rule, UGIDFW_BUFSIZ, errstr);
 	if (error) {
 		warnx("%s", errstr);
 		return;
@@ -168,7 +170,7 @@ set_rule(int argc, char *argv[])
 void
 remove_rule(int argc, char *argv[])
 {
-	char errstr[BUFSIZ];
+	char errstr[UGIDFW_BUFSIZ];
 	long value;
 	int error, rulenum;
 	char *endp;
@@ -185,7 +187,7 @@ remove_rule(int argc, char *argv[])
 
 	rulenum = value;
 
-	error = bsde_delete_rule(rulenum, BUFSIZ, errstr);
+	error = bsde_delete_rule(rulenum, UGIDFW_BUFSIZ, errstr);
 	if (error)
 		warnx("%s", errstr);
 }
